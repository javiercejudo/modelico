var version="24.0.1",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),innerOrigSymbol=Symbol("innerOrig");var symbols=Object.freeze({typeSymbol:typeSymbol,fieldsSymbol:fieldsSymbol,innerOrigSymbol:innerOrigSymbol});const get=(a)=>(b)=>b[a],pipe2=(a,b)=>(...c)=>b(a(...c)),not=(a)=>!a,identity=(a)=>a,pipe=(...a)=>[...a,identity].reduce(pipe2),partial=(a,...b)=>a.bind(void 0,...b),asIsReviver=(a)=>(b,c)=>a(c),always=(a)=>()=>a,isNothing=(a)=>null==a||Number.isNaN(a),isSomething=pipe2(isNothing,not),assertSomethingIdentity=(a)=>{if(isNothing(a))throw TypeError(`expected a value but got nothing (null, undefined or NaN)`);return a},defaultTo=(a)=>(b)=>isNothing(b)?a:b,objToArr=(a)=>Object.keys(a).map((b)=>[b,a[b]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(assertSomethingIdentity))),isPlainObject=(a)=>"object"==typeof a&&!!a,isFunction=(a)=>"function"==typeof a,emptyObject=Object.freeze({}),emptyArray=Object.freeze([]),haveSameValues=(c,a)=>c===a||Object.is(c,a),haveSameType=(c,a)=>null==c||null==a?c===a:c.constructor===a.constructor,haveDifferentTypes=pipe2(haveSameType,not),equals=(c,a)=>isSomething(c)&&c.equals?c.equals(a):haveSameValues(c,a),unsupported=(a)=>{throw Error(a)},metaOrTypeMapper=(a)=>(b)=>isPlainObject(b)?b:a(b),formatAjvError=(a,b,c,d=[])=>["Invalid JSON at \""+d.join(" -> ")+"\". According to the schema\n",JSON.stringify(b,null,2)+"\n","the value (data path \""+a.errors.filter((a)=>""!==a.dataPath).map((a)=>a.dataPath)+"\")\n",JSON.stringify(c,null,2)+" "+Object.prototype.toString.call(c)+"\n"].concat(a.errors.map((a)=>a.message)).join("\n"),memDefaultCacheFn=()=>new WeakMap,memFactory=(b=new WeakMap)=>{const a=(c,d=memDefaultCacheFn)=>(e,...a)=>{if(0<a.length)return c(e,...a);b.has(c)||b.set(c,d());const f=b.get(c)||d(),g=void 0===e?emptyObject:e;return f.has(g)||f.set(g,c(e,...a)),f.get(g)};return a.cache=()=>b,a.clear=()=>{return b=new WeakMap,a},a},mem=memFactory(),innerTypesCache=new WeakMap,getInnerTypes=(a,b)=>{return b.innerTypes(a,b)};var getInnerTypes$1=(a,b)=>{return innerTypesCache.has(b)||innerTypesCache.set(b,getInnerTypes(a,b)),innerTypesCache.get(b)||emptyObject};const metadataSchemaCache=new WeakMap;let state;const defaultState=()=>({nextRef:1,definitions:{},usedDefinitions:new Set,metadataRefCache:new WeakMap}),enhanceSchemaWithDefault=(a,b)=>{if(a.default===void 0)return b;const c={default:JSON.parse(JSON.stringify(a.default))};return b===emptyObject?Object.assign({},{type:emptyObject},c):Object.assign({},{anyOf:[{type:"null"},b]},a.type===M.Maybe?void 0:c)},getSchemaImpl=(a)=>{if(a.schema)return enhanceSchemaWithDefault(a,a.schema());const b=a.type&&a.type.innerTypes;if(!b)return enhanceSchemaWithDefault(a,emptyObject);const c=getInnerTypes$1([],a.type);if(0===Object.keys(c).length)return emptyObject;const d=[],e=Object.keys(c).reduce((a,b)=>{const e=c[b],f=getSchema(e,!1);return void 0===e.default&&d.push(b),Object.assign(a,{[b]:f})},{}),f=Object.assign({},{type:"object"},{properties:e});return 0<d.length&&(f.required=d),enhanceSchemaWithDefault(a,f)},getUsedDefinitions=()=>{const{definitions:a,usedDefinitions:b}=state;return Object.keys(a).map(Number).reduce((c,d)=>{return b.has(d)&&(c[d]=a[d]),c},{})},getSchema=(a,b=!0)=>{if(metadataSchemaCache.has(a))return metadataSchemaCache.get(a)||emptyObject;if(b&&(state=defaultState()),state.metadataRefCache.has(a)){const b=state.metadataRefCache.get(a)||state.nextRef;return state.usedDefinitions.add(b),{$ref:`#/definitions/${b}`}}const c=state.nextRef;state.metadataRefCache.set(a,c),state.nextRef+=1;const d=getSchemaImpl(a);if(Object.assign(state.definitions,{[c]:d}),!b){const b=state.metadataRefCache.get(a),c=Object.keys(d);return b&&(!(1>=c.length)||Array.isArray(d[c[0]]))?(state.usedDefinitions.add(b),{$ref:`#/definitions/${b}`}):d}const e=getUsedDefinitions();let f;return f=0===Object.keys(e).length?d:e.hasOwnProperty(c)?{definitions:Object.assign(e,{[c]:d}),$ref:`#/definitions/${c}`}:Object.assign({},d,{definitions:e}),metadataSchemaCache.set(a,f),f};var validate=(a,b=[])=>{if(!(a instanceof M.Base))throw TypeError("Modelico.validate only works with instances of Modelico.Base");try{M.genericsFromJSON(a[M.symbols.typeSymbol](),b,JSON.stringify(a))}catch(a){return[!1,a]}return[!0,void 0]};const defaultErrorMsgFn=(a,b)=>`Invalid value at "${b.join(" -> ")}"`;var withValidation=(a,b=defaultErrorMsgFn)=>(c)=>{return Object.assign({},c,{reviver:(d,e,f=[])=>{if(""!==d)return e;const g=c.reviver("",e,f);if(!a(g))throw TypeError(b(g,f));return g}})};const cacheRegistry=new WeakMap,withCache=(a,b,c=[],d=b)=>{cacheRegistry.has(a)||cacheRegistry.set(a,new Map);const e=cacheRegistry.get(a);return e.has(d)||e.set(d,b.apply(a,c)),e.get(d)};var asIs=mem((a=identity)=>Object.freeze({type:a,reviver:asIsReviver(pipe(assertSomethingIdentity,a)),maybeReviver:asIsReviver(a)})),any=always(asIs(identity)),anyOf=(a=[],b="type")=>(c,d)=>{if(0===a.length)return any;const e=a[0][1][typeSymbol](),f=e.metadata().reviver("",c[b]);for(let b=0;b<a.length;b+=1){const c=a[b],d=c[0],e=c[1];if(f===e)return d}const g=d.slice(0,-1);throw TypeError(`unsupported enumerator "${f.toJSON()}" at "${g.join(" -> ")}"`)};const plainObjectReviverFactory=(a,b,c,d)=>Object.keys(c).reduce((e,f)=>{const g=d.concat(f),h=getInnerTypes$1(d,a),i=h[f],j=isFunction(i)?i(c,g):i;return e[f]=j?reviverOrAsIs(j)(b,c[f],g):c[f],e},{}),reviverFactory=(a)=>(b,c,d=[])=>{if(""!==b)return c;const e=isPlainObject(c)?plainObjectReviverFactory(a,b,c,d):c;return new a(e)},isMatch=(a)=>(b)=>{const c=b.type.innerTypes(),d=Object.keys(c),e=isPlainObject(a);return 0===d.length&&e?!1:d.filter((a)=>!c[a].hasOwnProperty("default")).every((b)=>!!e&&a.hasOwnProperty(b))},inferClassifier=(a)=>(b)=>{const c=a.filter(isMatch(b),[]);if(0===c.length)throw Error("Unable to infer type");if(1<c.length)throw Error("Ambiguous object: more than one metadata matches the object. A custom classifier can be passed as a second argument.");return c[0]},getPathReducer=(a,b)=>a.get(b);class Base{constructor(a,b=emptyObject,c){if(!isPlainObject(b))throw TypeError(`expected an object with fields for ${a.displayName||a.name} but got ${b}`);Object.freeze(b);const d={},e=getInnerTypes$1([],a);c=defaultTo(this)(c),c[typeSymbol]=always(a),Object.keys(e).forEach((f)=>{const g=b[f],h=e[f].default;let i;if(isSomething(g))i=g;else if(h!==void 0)i=h,d[f]=i;else throw TypeError(`no value for key "${f}" of ${a.displayName||a.name}`);c[f]=always(i)}),c[fieldsSymbol]=always(Object.freeze(Object.assign(d,b)))}get[Symbol.toStringTag](){return"ModelicoModel"}get(a){return this[fieldsSymbol]()[a]}getIn(a){return a.reduce(getPathReducer,this)}copy(a){const b=Object.assign({},this[fieldsSymbol](),a);return new(this[typeSymbol]())(b)}set(a,b){return this.copy({[a]:b})}setIn(a,b){if(0===a.length)return this.copy(b);const[c,...d]=a,e=this[c]();return e.setIn?this.set(c,e.setIn(d,b)):this.set(c,b)}equals(a){if(this===a)return!0;if(haveDifferentTypes(this,a))return!1;const b=this[fieldsSymbol](),c=a[fieldsSymbol](),d=Object.keys(b),e=Object.keys(c);return!(d.length!==e.length)&&d.every((a)=>equals(b[a],c[a]))}toJSON(){return this[fieldsSymbol]()}toJS(){return JSON.parse(JSON.stringify(this))}stringify(a){return JSON.stringify(this,null,a)}static innerTypes(){return emptyObject}static factory(...a){return new Base(...a)}}var Base$1=Object.freeze(Base);const set=(a,b,c,d)=>{const e=a.inner();return e.set(c,d),b.fromMap(e)},of=(a,b)=>{const c=b.length;if(1==c%2)throw TypeError(`${a.displayName}.of requires an even number of arguments`);const d=new Map;for(let a=0;a<c;a+=2)d.set(b[a],b[a+1]);return a.fromMap(d)},metadata$2=mem((a)=>mem((b)=>mem((c)=>mem((d)=>{return Object.freeze({type:a,subtypes:Object.freeze([c,d]),reviver:b(c,d)})})))),equalPairs=(a,b)=>a.every((a,c)=>equals(a,b[c])),copy=(a)=>new Map(a);class AbstractMap extends Base$1{constructor(a,b=new Map,c){if(super(a),isNothing(b))throw TypeError("missing map");if(c&&0===b.size)return c;const d=copy(b);this[innerOrigSymbol]=always(d),this.inner=()=>copy(d),this.size=d.size}[Symbol.iterator](){return this[innerOrigSymbol]()[Symbol.iterator]()}has(a){return this[innerOrigSymbol]().has(a)}get(a){return this[innerOrigSymbol]().get(a)}setIn(a,b){if(0===a.length)return new(this[typeSymbol]())(b);const[c,...d]=a,e=this[innerOrigSymbol]().get(c);return e.setIn?this.set(c,e.setIn(d,b)):this.set(c,b)}equals(a,b=!1){if(this===a)return!0;if(haveDifferentTypes(this,a)||this.size!==a.size)return!1;const c=this[Symbol.iterator](),d=a[Symbol.iterator]();for(let e=0;e<this.size;e+=1){const e=c.next().value,f=b?a.has(e[0])&&equals(e[1],a.get(e[0])):equalPairs(e,d.next().value);if(!f)return!1}return!0}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(a,b,c)=>(d,e)=>[a("",d[0],c.concat(e,0)),b("",d[1],c.concat(e,1))],reviverFactory$2=(a,b)=>(c,d,e=[])=>{if(""!==c)return d;const f=reviverOrAsIs(isFunction(a)?a(d,e):a),g=reviverOrAsIs(isFunction(b)?b(d,e):b),h=null===d?null:new Map(d.map(parseMapper(f,g,e)));return ModelicoMap.fromMap(h)};let EMPTY_MAP;class ModelicoMap extends AbstractMap$1{constructor(a){super(ModelicoMap,a,EMPTY_MAP),EMPTY_MAP||0!==this.size||(EMPTY_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMap"}set(a,b){return set(this,ModelicoMap,a,b)}toJSON(){return[...this]}static fromMap(a){return new ModelicoMap(a)}static fromArray(a){return ModelicoMap.fromMap(new Map(a))}static of(...a){return of(ModelicoMap,a)}static fromObject(a){return ModelicoMap.fromArray(objToArr(a))}static metadata(a,b){return metadata$2(ModelicoMap)(reviverFactory$2)(a)(b)}static EMPTY(){return EMPTY_MAP||ModelicoMap.of()}}ModelicoMap.displayName="ModelicoMap";var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(a,b)=>{return a[b[0]]=b[1],a},parseReducer=(a,b,c)=>(d,e)=>[...d,[e,a("",b[e],c.concat(e))]],reviverFactory$3=(a)=>(b,c,d=[])=>{if(""!==b)return c;const e=reviverOrAsIs(isFunction(a)?a(c,d):a),f=null===c?null:new Map(Object.keys(c).reduce(parseReducer(e,c,d),[]));return StringMap.fromMap(f)};let EMPTY_STRING_MAP;class StringMap extends AbstractMap$1{constructor(a){super(StringMap,a,EMPTY_STRING_MAP),EMPTY_STRING_MAP||0!==this.size||(EMPTY_STRING_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoStringMap"}set(a,b){return set(this,StringMap,a,b)}toJSON(){return[...this].reduce(stringifyReducer,{})}static fromMap(a){return new StringMap(a)}static fromArray(a){return StringMap.fromMap(new Map(a))}static of(...a){return of(StringMap,a)}static fromObject(a){return StringMap.fromArray(objToArr(a))}static metadata(a){return metadata$2(StringMap)(reviverFactory$3)(a)()}static EMPTY(){return EMPTY_STRING_MAP||StringMap.of()}}StringMap.displayName="StringMap";var StringMap$1=Object.freeze(StringMap);const stringifyReducer$1=(a,b)=>{return a[b[0].toJSON()]=b[1],a},parseMapper$1=(a,b,c,d)=>(e)=>{const f=a("",e,d),g=b("",c[e],d.concat(e));return[f,g]},reviverFactory$4=(a,b)=>(c,d,e=[])=>{if(""!==c)return d;const f=reviverOrAsIs(isFunction(a)?a(d,e):a),g=reviverOrAsIs(isFunction(b)?b(d,e):b),h=null===d?null:new Map(Object.keys(d).map(parseMapper$1(f,g,d,e)));return new EnumMap(h)};let EMPTY_ENUM_MAP;class EnumMap extends AbstractMap$1{constructor(a){super(EnumMap,a,EMPTY_ENUM_MAP),EMPTY_ENUM_MAP||0!==this.size||(EMPTY_ENUM_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoEnumMap"}set(a,b){return set(this,EnumMap,a,b)}toJSON(){return[...this].reduce(stringifyReducer$1,{})}static fromMap(a){return new EnumMap(a)}static fromArray(a){return EnumMap.fromMap(new Map(a))}static of(...a){return of(EnumMap,a)}static metadata(a,b){return metadata$2(EnumMap)(reviverFactory$4)(a)(b)}static EMPTY(){return EMPTY_ENUM_MAP||EnumMap.of()}}EnumMap.displayName="EnumMap";var EnumMap$1=Object.freeze(EnumMap);const reviver=(a,b)=>{return ModelicoNumber.of(b)},metadata$3=mem(()=>Object.freeze({type:ModelicoNumber,reviver}));class ModelicoNumber extends Base$1{constructor(a=0){if(super(ModelicoNumber),!Number.isNaN(a)&&isNothing(a))throw TypeError("missing number");this.inner=always(+a),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoNumber"}set(){unsupported("Number.set is not supported")}setIn(a,b){return 0===a.length?ModelicoNumber.of(b):void unsupported("ModelicoNumber.setIn is not supported for non-empty paths")}toJSON(){const a=this.inner();return Object.is(a,-0)?"-0":a===Infinity?"Infinity":a===-Infinity?"-Infinity":Number.isNaN(a)?"NaN":a}equals(a){return!(this!==a)||!haveDifferentTypes(this,a)&&haveSameValues(this.inner(),a.inner())}static of(a){return new ModelicoNumber(a)}static metadata(){return metadata$3()}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(a,b)=>{const c=null===b?null:new Date(b);return new ModelicoDate(c)},metadata$4=mem(()=>Object.freeze({type:ModelicoDate,reviver:reviver$1}));class ModelicoDate extends Base$1{constructor(a=new Date){if(super(ModelicoDate),isNothing(a))throw TypeError("missing date");const b=new Date(a.getTime());this.inner=()=>new Date(b.getTime()),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoDate"}set(){unsupported("Date.set is not supported")}setIn(a,b){return 0===a.length?ModelicoDate.of(b):void unsupported("Date.setIn is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(a){return!(this!==a)||!haveDifferentTypes(this,a)&&this.toJSON()===a.toJSON()}static of(a){return new ModelicoDate(a)}static metadata(){return metadata$4()}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(a,b)=>(c,d,e=[])=>{if(""!==c)return d;const f=Array.isArray(b);if(f&&d.length!==b.length)throw TypeError("tuple has missing or extra items");const g=f?(a)=>isFunction(b[a])?b[a](d,e):b[a]:isFunction(b)?()=>b(d,e):()=>b,h=null===d?null:d.map((a,b)=>reviverOrAsIs(g(b))("",a,e.concat(b)));return new a(h)},iterableMetadata=mem((a)=>mem((b)=>{return Object.freeze({type:a,subtypes:Object.freeze([b]),reviver:iterableReviverFactory(a,b)})})),iterableEquals=(a,b,c=!1)=>{if(a===b)return!0;if(haveDifferentTypes(a,b)||a.size!==b.size)return!1;const d=a[Symbol.iterator](),e=b[Symbol.iterator]();for(let f=0;f<a.size;f+=1){const a=d.next().value;if(c){if(!b.has(a))return!1;}else if(!equals(a,e.next().value))return!1}return!0};let EMPTY_LIST;class List extends Base$1{constructor(a=[]){if(super(List),isNothing(a))throw TypeError("missing list");return EMPTY_LIST&&0===a.length?EMPTY_LIST:void(Object.freeze(a),this.inner=always(a),this[innerOrigSymbol]=this.inner,this.size=a.length,!EMPTY_LIST&&0===this.size&&(EMPTY_LIST=this),Object.freeze(this))}get[Symbol.toStringTag](){return"ModelicoList"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}includes(...a){return this.inner().includes(...a)}get(a){return this.inner()[a]}set(a,b){const c=[...this];return c[a]=b,List.fromArray(c)}setIn(a,b){if(0===a.length)return List.fromArray(b);const[c,...d]=a,e=this.inner()[c];return e.setIn?this.set(c,e.setIn(d,b)):this.set(c,b)}toJSON(){return this.inner()}toArray(){return this.toJSON()}equals(a){return iterableEquals(this,a)}static fromArray(a){return new List(a)}static of(...a){return List.fromArray(a)}static metadata(a){return iterableMetadata(List)(a)}static EMPTY(){return EMPTY_LIST||List.of()}}List.displayName="List";var List$1=Object.freeze(List);let EMPTY_SET;const copy$1=(a)=>new Set(a);class ModelicoSet extends Base$1{constructor(a=new Set){if(super(ModelicoSet),isNothing(a))throw TypeError("missing set");if(EMPTY_SET&&0===a.size)return EMPTY_SET;const b=copy$1(a);this[innerOrigSymbol]=always(b),this.inner=()=>copy$1(b),this.size=b.size,EMPTY_SET||0!==this.size||(EMPTY_SET=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoSet"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}has(a){return this[innerOrigSymbol]().has(a)}set(){unsupported("Set.set is not supported")}setIn(a,b){return 0===a.length?new ModelicoSet(b):void unsupported("Set.setIn is not supported for non-empty paths")}toJSON(){return[...this]}equals(...a){return iterableEquals(this,...a)}static fromSet(a){return new ModelicoSet(a)}static fromArray(a){return ModelicoSet.fromSet(new Set(a))}static of(...a){return ModelicoSet.fromArray(a)}static metadata(a){return iterableMetadata(ModelicoSet)(a)}static EMPTY(){return EMPTY_SET||ModelicoSet.of()}}ModelicoSet.displayName="ModelicoSet";var ModelicoSet$1=Object.freeze(ModelicoSet);const reviverFactory$5=(a)=>(b,c,d)=>{if(""!==b)return c;if(null===c)return new Nothing;const e=isFunction(a)?a(c,d):a,f=defaultTo(e.reviver)(e.maybeReviver),g=f(b,c,d);return Maybe.of(g)},metadata$5=mem((a)=>Object.freeze({type:Maybe,subtypes:[a],reviver:reviverFactory$5(a),default:new Nothing}));class Maybe extends Base$1{get(a){const b=a[0],c=a[1],d=this.getOrElse(b);return d.get?d.get(c):d}set(a,b){if(this.isEmpty())return this;const c=this.inner();if(isNothing(c))return this;const d=c.set?c.set(a,b):null;return Maybe.of(d)}setIn(a,b){if(0===a.length)return Maybe.of(b);const[c,...d]=a,e=c[0],f=c[1],g=this.isEmpty()?e:this.inner(),h=g.setIn?g.setIn([f,...d],b):null;return Maybe.of(h)}static of(a){return isNothing(a)||a instanceof Nothing?new Nothing:new Just(a)}static metadata(a){return metadata$5(a)}}Maybe.displayName="Maybe";let nothing;class Nothing extends Maybe{constructor(){return super(Nothing),nothing||(this.inner=()=>{throw TypeError("nothing holds no value")},nothing=this),nothing}get[Symbol.toStringTag](){return"ModelicoNothing"}toJSON(){return null}isEmpty(){return!0}getOrElse(a){return a}map(){return this}flatMap(){return this}equals(a){return this===a}}Nothing.displayName="Nothing";class Just extends Maybe{constructor(a){super(Just),this.inner=always(a),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoJust"}toJSON(){const a=this.inner();return isNothing(a)?null:a.toJSON?a.toJSON():a}isEmpty(){return!1}getOrElse(){return this.inner()}map(a){return Just.of(a(this.inner()))}flatMap(a){const b=a(this.inner());if(!(b instanceof Maybe))throw TypeError("Maybe.flatMap expects a Maybe-returning function");return b}equals(a){return!(this!==a)||!haveDifferentTypes(this,a)&&equals(this.inner(),a.inner())}static of(a){return new Just(a)}}Just.displayName="Just",Maybe.Nothing=new Nothing,Maybe.Just=Just;var Maybe$1=Object.freeze(Maybe);const base=mem((a)=>Object.freeze({type:a,reviver:reviverFactory(a)})),_impl=(a,b)=>a.metadata?a.metadata(...b):base(a),_implMem=mem((a)=>mem((b)=>_impl(a,b))),_$1=(a,b=emptyArray)=>_implMem(a)(b),withDefaultImpl=(a,b)=>{return Object.freeze(Object.assign({},a,{default:b,reviver:(c,d,e=[])=>{if(""!==c)return d;if(isNothing(d)){const d=defaultTo(a)(a.baseMetadata);return d.reviver(c,b,e)}return a.reviver(c,d,e)}}))},withDefaultMem=mem((a)=>mem((b)=>withDefaultImpl(a,b),()=>new Map)),withDefault=(a,b)=>withDefaultMem(a)(b),union=(a,b,c)=>{const d=b.map(metaOrTypeMapper(_$1));c=c===void 0?inferClassifier(d):c;return Object.assign({},base(a),{reviver:(a,b,e=[])=>{return""===a?c(b,d).reviver(a,b,e):b},subtypes:d})},metadata$1=always(Object.freeze({_:_$1,base,asIs,any,anyOf,union,number:always(asIs(Number)),string:always(asIs(String)),boolean:always(asIs(Boolean)),wrappedNumber:ModelicoNumber$1.metadata,date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$1.metadata,map:ModelicoMap$1.metadata,stringMap:StringMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata,withDefault})),getInnerSchema=(a)=>M.getSchema(a,!1),alwaysEmptyString=always(""),triviallyValidResult=[!0,alwaysEmptyString],jsonSchemaMetadata=(a)=>{const b=M.getSchema,c=M.metadata(),d={},{_:e,base:f,asIs:g,any:h,anyOf:i,union:j,string:k,number:l,wrappedNumber:m,boolean:n,date:o,enumMap:p,list:q,map:r,stringMap:s,set:t,maybe:u,withDefault:v}=c,w=(b,c,d=identity,e="reviver")=>(f,g,h=[])=>{if(""!==f)return g;const i=c===emptyObject?triviallyValidResult:a(c,d(g),h);if(!i[0])throw TypeError(i[1]());const j=isFunction(b)?b(g,h):b;return j[e]("",g,h)},x=(a,b,c,d)=>(e,f,g=[])=>{if(""!==e)return f;const i=w(a,b,identity,d)(e,f);return w(h(),c,(a)=>a.inner(),d)(e,i,g)},y=(a,b,c=emptyObject,d=always(emptyObject))=>{const e=b===emptyObject&&c===emptyObject?emptyObject:Object.assign({},b,c),f=w(a,e),g=isFunction(a)?{type:a}:a,h=Object.assign({},g,{baseMetadata:g,reviver:f,ownSchema:always(e),schema:()=>Object.assign({},e,d())});return a.maybeReviver&&(h.maybeReviver=w(a,e,identity,"maybeReviver")),h};d.meta=y;const z=(a,c,d,f)=>{const g=e(a,c);return d===emptyObject?g:y(g,emptyObject,d,()=>b(g,f))},A=mem((a)=>mem((b)=>mem((c)=>mem((d)=>z(a,b,c,d),()=>new Map))));d._=(a,b,c=emptyObject,d=!1)=>A(a)(b)(c)(d);const B=(a,c,d)=>{const e=f(a);return c===emptyObject?e:y(e,{type:"object"},c,()=>b(e,d))},C=mem((a)=>mem((b)=>mem((c)=>B(a,b,c),()=>new Map)));d.base=(a,b=emptyObject,c=!1)=>C(a)(b)(c);const D=(a,b)=>y(g(a),b),E=mem((a)=>mem((b)=>D(a,b)));d.asIs=(a,b)=>E(a)(b),d.any=(a)=>d.asIs(identity,a),d.wrappedNumber=mem((a)=>{const b=m(),c=Object.assign({type:"number"},a),d={anyOf:[{type:"number"},{enum:["-0","-Infinity","Infinity","NaN"]}]},e=x(b,d,c);return Object.assign({},b,{reviver:e,ownSchema:always(d),schema:always(d)})}),d.number=mem((a)=>y(l(),{type:"number"},a)),d.string=mem((a)=>y(k(),{type:"string"},a)),d.boolean=mem((a)=>y(n(),{type:"boolean"},a)),d.date=mem((a)=>y(o(),{type:"string",format:"date-time"},a)),d._enum=mem((a)=>{const b=e(a);return y(b,{enum:Object.keys(b.enumerators)})});const F=(a,b,c)=>{const d=Object.keys(a.enumerators),e=`^(${d.join("|")})$`;return y(p(a,b),{type:"object",maxProperties:d.length,additionalProperties:!1,patternProperties:{[e]:{}}},c,()=>({patternProperties:{[e]:getInnerSchema(b,!1)}}))},G=mem((a)=>mem((b)=>mem((c)=>F(a,b,c))));d.enumMap=(a,b,c)=>G(a)(b)(c);const H=(a,b)=>y(q(a),{type:"array"},b,()=>({items:getInnerSchema(a)})),I=mem((a)=>mem((b)=>H(a,b))),J=(a,b)=>{const c=a.length;return y(q(a),{type:"array",minItems:c,maxItems:c},b,()=>({items:a.map((a)=>getInnerSchema(a))}))},K=mem((a)=>mem((b)=>J(a,b)));d.list=(a,b)=>Array.isArray(a)?K(a)(b):I(a)(b);const L=(a,b,c)=>{const d={type:"array",items:{type:"array",minItems:2,maxItems:2}};return y(r(a,b),d,c,()=>({items:Object.assign({items:[getInnerSchema(a),getInnerSchema(b)]},d.items)}))},N=mem((a)=>mem((b)=>mem((c)=>L(a,b,c))));d.map=(a,b,c)=>N(a)(b)(c);const O=(a,b)=>y(s(a),{type:"object"},b,()=>({additionalProperties:!1,patternProperties:{".*":getInnerSchema(a)}})),P=mem((a)=>mem((b)=>O(a,b)));d.stringMap=(a,b)=>P(a)(b);const Q=(a,b)=>y(t(a),{type:"array",uniqueItems:!0},b,()=>({items:getInnerSchema(a)})),R=mem((a)=>mem((b)=>Q(a,b)));d.set=(a,b)=>R(a)(b);const S=(a,b)=>y(u(a),emptyObject,b,()=>getInnerSchema(a)),T=mem((a)=>mem((b)=>S(a,b)));d.maybe=(a,b)=>T(a)(b);const U=(a,b,c)=>y(v(a,b),emptyObject,c,()=>getInnerSchema(a)),V=mem((a)=>mem((b)=>mem((c)=>U(a,b,c)),()=>new Map));return d.withDefault=(a,b,c)=>V(a)(b)(c),d.anyOf=(a,b)=>y(i(a,b),{anyOf:a.map((a)=>getInnerSchema(a[0]))}),d.union=(a,b,c)=>{const d=b.map(metaOrTypeMapper(e)),f=j(a,d,c);return y(f,emptyObject,emptyObject,()=>({anyOf:d.map(getInnerSchema)}))},Object.freeze(Object.assign({},c,d))};var jsonSchemaMetadata$1=mem((a=()=>triviallyValidResult)=>jsonSchemaMetadata(a));const ajvMetadata=mem((a)=>{return jsonSchemaMetadata$1(a===void 0?void 0:(b,c,d)=>[a.validate(b,c),partial(formatAjvError,a,b,c,d)])}),enumeratorsReducer=(a,b)=>Object.assign(a,{[b]:{code:b}}),reviverFactory$6=(a)=>(b,c,d=[])=>{const e=a[c];if(isNothing(e))throw TypeError(`missing enumerator "${c}" at "${d.join(" -> ")}"`);return e};class Enum extends Base$1{constructor(a,b=Enum,c=b.displayName){const d=Array.isArray(a)?a.reduce(enumeratorsReducer,{}):a;b!==Enum&&(b.displayName=c,Object.freeze(b)),super(b),Object.getOwnPropertyNames(d).forEach((a)=>{this[a]=always(d[a]),d[a][typeSymbol]=always(this),d[a].toJSON=always(a),d[a].equals=(b)=>d[a]===b}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:this,enumerators:d,reviver:reviverFactory$6(d)}))})}static fromObject(...a){return new Enum(...a)}static fromArray(...a){return new Enum(...a)}}Object.defineProperty(Enum,"displayName",{value:"Enum",writable:!0});const proxyToSelf=(a,b,c,d,e)=>{return a.includes(e)?(...f)=>{const g=d[e](...f);return proxyFactory(a,b,c,g)}:d[e]},proxyToInner=(a,b,c,d,e,f,g)=>{return c.includes(g)?(...g)=>{const h=f.setIn([],b.apply(a,g));return proxyFactory(c,d,e,h)}:d.includes(g)?(...g)=>{b.apply(a,g);const h=f.setIn([],a);return proxyFactory(c,d,e,h)}:(...c)=>{return b.apply(a,c)}},proxyFactory=(a,b,c,d)=>{return new Proxy(d,{get:(d,e)=>{if(e in d)return proxyToSelf(a,b,c,d,e);const f=c(d.inner()),g=f[e];return"function"==typeof g?proxyToInner(f,g,a,b,c,d,e):g}})},metadata$6=metadata$1(),createModel=(a=emptyObject,{base:b=Base$1,stringTag:c="ModelicoModel",metadata:d=metadata$6}={})=>{const e=class extends b{constructor(){const a=arguments;if(2===a.length)super(a[0],a[1]);else{const b=a[0],c=void 0===b?{}:b;super(e,c)}}get[Symbol.toStringTag](){return c}static innerTypes(b,c){return isFunction(a)?a(d,{path:b,Type:c}):Object.freeze(a)}};return e.displayName=c,e},{union:defaultUnion}=metadata$1(),createUnionType=(a,b,c=defaultUnion)=>{const d=a.map((a)=>isPlainObject(a)&&!(a instanceof M.Enum)?a:M.metadata()._(a));b=b===void 0?inferClassifier(d):b;const e=d.length;class f extends M.Base{static caseOf(...a){const b=new Map(a),c=b.size;if(e!==c)throw Error(`caseOf expected ${e} but contains ${c}`);if(!d.every((a)=>b.has(a.type)))throw Error("caseOf does not cover all cases");return(a,c)=>{const d=a[typeSymbol],e=d?d():a.constructor,f=b.get(e),g=f===void 0?c:f;return isFunction(g)?g(a):g}}static metadata(){return c(f,d,b)}}return f},{_}=metadata$1(),internalNonMutators=["set","setIn"],mapNonMutators=internalNonMutators,mapMutators=["delete","clear"],setNonMutators=internalNonMutators,setMutators=["add","delete","clear"],listNonMutators=internalNonMutators.concat(["map","concat","slice","filter"]),listMutators=["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],proxyMap=partial(proxyFactory,mapNonMutators,mapMutators,identity),genericsFromJS=(a,b,c)=>_(a,b).reviver("",c),fromJS=(a,b)=>genericsFromJS(a,[],b),ajvGenericsFromJS=(a,b,c,d,e)=>a(b,d,c).reviver("",e),ajvFromJS=(a,b,c,d)=>ajvGenericsFromJS(a,b,c,[],d),createAjvModel=(a,b,c={})=>{return c.metadata=ajvMetadata(a),createModel(b,c)},createSimpleModel=(a,b)=>createModel(b,{stringTag:a});var M={about:Object.freeze({version,author,homepage,license}),Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum,EnumMap:EnumMap$1,List:List$1,Map:ModelicoMap$1,StringMap:StringMap$1,Maybe:Maybe$1,Just:Maybe$1.Just,Nothing:Maybe$1.Nothing,Base:Base$1,Set:ModelicoSet$1,createModel,createSimpleModel,createAjvModel,createUnionType,new:(a)=>(b)=>new a(b),fields:(a)=>a[fieldsSymbol](),symbols,fromJS,genericsFromJS,fromJSON:(a,b)=>fromJS(a,JSON.parse(b)),genericsFromJSON:(a,b,c)=>genericsFromJS(a,b,JSON.parse(c)),ajvFromJS,ajvGenericsFromJS,ajvFromJSON:(a,b,c,d)=>ajvFromJS(a,b,c,JSON.parse(d)),ajvGenericsFromJSON:(a,b,c,d,e)=>ajvGenericsFromJS(a,b,c,d,JSON.parse(e)),metadata:metadata$1,jsonSchemaMetadata:jsonSchemaMetadata$1,ajvMetadata,getSchema,validate,withValidation,withCache,proxyMap,proxyEnumMap:proxyMap,proxyStringMap:proxyMap,proxyList:partial(proxyFactory,listNonMutators,listMutators,(a)=>[...a]),proxySet:partial(proxyFactory,setNonMutators,setMutators,identity),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators,identity),util:{always,formatAjvError,identity,isNothing,partial,pipe,mem,memFactory}};export default M;

