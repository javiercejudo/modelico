var _NumberisNaN=Number.isNaN,version="21.4.0",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),innerOrigSymbol=Symbol("innerOrig");var symbols=Object.freeze({typeSymbol:typeSymbol,fieldsSymbol:fieldsSymbol,innerOrigSymbol:innerOrigSymbol});const get=(c)=>(h)=>h[c],pipe2=(c,h)=>(...j)=>h(c(...j)),not=(c)=>!c,T=()=>!0,identity=(c)=>c,pipe=(...c)=>[...c,identity].reduce(pipe2),partial=(c,...h)=>c.bind(void 0,...h),asIsReviver=(c)=>(h,j)=>c(j),always=(c)=>()=>c,isNothing=(c)=>null==c||_NumberisNaN(c),isSomething=pipe2(isNothing,not),assertSomethingIdentity=(c)=>{if(isNothing(c))throw TypeError(`expected a value but got nothing (null, undefined or NaN)`);return c},defaultTo=(c)=>(h)=>isNothing(h)?c:h,objToArr=(c)=>Object.keys(c).map((h)=>[h,c[h]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(assertSomethingIdentity))),isPlainObject=(c)=>"object"==typeof c&&!!c,isFunction=(c)=>"function"==typeof c,emptyObject=Object.freeze({}),haveSameValues=(c,h)=>c===h||Object.is(c,h),haveSameType=(c,h)=>null==c||null==h?c===h:c.constructor===h.constructor,haveDifferentTypes=pipe2(haveSameType,not),equals=(c,h)=>isSomething(c)&&c.equals?c.equals(h):haveSameValues(c,h),unsupported=(c)=>{throw Error(c)},innerTypesCache=new WeakMap,getInnerTypes=(c,h)=>{if(!h.innerTypes)throw Error(`missing static innerTypes for ${h.displayName||h.name}`);return h.innerTypes(c,h)};var getInnerTypes$1=(c,h)=>{return innerTypesCache.has(h)||innerTypesCache.set(h,getInnerTypes(c,h)),innerTypesCache.get(h)};const plainObjectReviverFactory=(c,h,j,l)=>Object.keys(j).reduce((m,o)=>{const p=l.concat(o),q=getInnerTypes$1(l,c),r=q[o],s=isFunction(r)?r(j,p):r;return m[o]=s?reviverOrAsIs(s)(h,j[o],p):j[o],m},{}),reviverFactory=(c)=>(h,j,l=[])=>{if(""!==h)return j;const m=isPlainObject(j)?plainObjectReviverFactory(c,h,j,l):j;return new c(m)},metadataSchemaCache=new WeakMap,metadataRefCache=new WeakMap,state={nextRef:1,definitions:{},usedDefinitions:new Set},getSchemaImpl=(c)=>{if(c.schema)return c.schema();if(!c.type||!c.type.innerTypes||0===Object.keys(getInnerTypes$1([],c.type)).length)return emptyObject;const j=c.type.innerTypes(),l=[],m=Object.keys(j).reduce((p,q)=>{const r=j[q],s=getSchema(r,!1);let t;return void 0===r.default?(l.push(q),t=s):t=Object.assign({anyOf:[{type:"null"},s]},r.type===M.Maybe?void 0:{default:r.default}),Object.assign(p,{[q]:t})},{}),o=Object.assign({},{type:"object"},{properties:m});return 0<l.length&&(o.required=l),o},getUsedDefinitions=()=>{const{definitions:c,usedDefinitions:h}=state;return Object.keys(c).map(Number).reduce((j,l)=>{return h.has(l)&&(j[l]=c[l]),j},{})},schemaDeclaration=(c,h)=>""===h?c:Object.assign({$schema:h},c),getSchema=(c,h=!0,j="")=>{if(metadataSchemaCache.has(c))return schemaDeclaration(metadataSchemaCache.get(c),j);if(metadataRefCache.has(c)){const p=metadataRefCache.get(c);return state.usedDefinitions.add(p),{$ref:`#/definitions/${p}`}}h&&(state.nextRef=1,state.definitions={},state.usedDefinitions=new Set);const l=state.nextRef;metadataRefCache.set(c,l),state.nextRef+=1;const m=getSchemaImpl(c);if(metadataSchemaCache.set(c,m),Object.assign(state.definitions,{[l]:m}),!h)return m;const o=getUsedDefinitions();return 0===Object.keys(o).length?schemaDeclaration(m,j):schemaDeclaration({definitions:Object.assign(o,{[l]:m}),$ref:`#/definitions/${l}`},j)};var validate=(c,h=[])=>{try{M.genericsFromJSON(c[M.symbols.typeSymbol](),h,JSON.stringify(c))}catch(j){return[!1,j]}return[!0,void 0]};const defaultErrorMsgFn=(c,h)=>`Invalid value at "${h.join(" > ")}"`;var withValidation=(c,h=defaultErrorMsgFn)=>(j)=>{return Object.assign({},j,{reviver:(m,o,p=[])=>{if(""!==m)return o;const q=j.reviver("",o,p);if(!c(q))throw TypeError(h(q,p));return q}})};const getPathReducer=(c,h)=>c.get(h);class Base{constructor(c,h=emptyObject,j){if(!isPlainObject(h))throw TypeError(`expected an object with fields for ${c.displayName||c.name} but got ${h}`);Object.freeze(h);const l={},m=getInnerTypes$1([],c);j=defaultTo(this)(j),j[typeSymbol]=always(c),Object.keys(m).forEach((o)=>{const p=h[o],q=m[o].default;let r;if(isSomething(p))r=p;else if(isSomething(q))r=m[o].default,l[o]=r;else throw TypeError(`no value for key "${o}"`);j[o]=always(r)}),j[fieldsSymbol]=always(Object.freeze(Object.assign(l,h)))}get[Symbol.toStringTag](){return"ModelicoModel"}get(c){return this[fieldsSymbol]()[c]}getIn(c){return c.reduce(getPathReducer,this)}set(c,h){const j=Object.assign({},this[fieldsSymbol](),{[c]:h});return new(this[typeSymbol]())(j)}setIn(c,h){if(0===c.length)return new(this[typeSymbol]())(h);const[j,...l]=c,m=this[j]();return m.setIn?this.set(j,m.setIn(l,h)):this.set(j,h)}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const h=this[fieldsSymbol](),j=c[fieldsSymbol](),l=Object.keys(h),m=Object.keys(j);return!(l.length!==m.length)&&l.every((o)=>equals(h[o],j[o]))}toJSON(){return this[fieldsSymbol]()}toJS(){return JSON.parse(JSON.stringify(this))}stringify(c){return JSON.stringify(this,null,c)}static factory(...c){return new Base(...c)}}var Base$1=Object.freeze(Base);const reviverFactory$2=(c)=>(h,j,l)=>{if(""!==h)return j;const m=isFunction(c)?c(j,l):c,o=null===j?always(null):defaultTo(m.reviver)(m.maybeReviver);return new Maybe(o(h,j,l))};class Nothing{toJSON(){return null}}class Just{constructor(c){this.get=always(c),Object.freeze(this)}toJSON(){const c=this.get();return isNothing(c)?null:c.toJSON?c.toJSON():c}}const nothing=new Nothing;class Maybe extends Base$1{constructor(c,h=!0){super(Maybe);const j=h&&isNothing(c)?nothing:new Just(c);this.inner=always(j),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMaybe"}get(c){const h=c[0],j=c[1],l=this.getOrElse(h);return l.get?l.get(j):l}set(c,h){if(this.isEmpty())return this;const j=this.inner().get();if(isNothing(j))return this;const l=j.set?j.set(c,h):null;return new Maybe(l)}setIn(c,h){if(0===c.length)return Maybe.of(h);const[j,...l]=c,m=j[0],o=j[1],p=this.isEmpty()?m:this.inner().get(),q=p.setIn?p.setIn([o,...l],h):null;return Maybe.of(q)}isEmpty(){return this.inner()===nothing}getOrElse(c){return this.isEmpty()?c:this.inner().get()}map(c){return this.isEmpty()?this:Maybe.ofAny(c(this.inner().get()))}toJSON(){return this.inner().toJSON()}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const h=this.inner(),j=c.inner();return this.isEmpty()||c.isEmpty()?h===j:equals(h.get(),j.get())}static of(c){return new Maybe(c)}static ofAny(c){return new Maybe(c,!1)}static metadata(c){return Object.freeze({type:Maybe,subtypes:[c],reviver:reviverFactory$2(c),default:Maybe.of()})}static innerTypes(){return emptyObject}}Maybe.displayName="Maybe",Maybe.EMPTY=Maybe.of();var Maybe$1=Object.freeze(Maybe);const enumeratorsReducer=(c,h)=>Object.assign(c,{[h]:{code:h}}),reviverFactory$3=(c)=>(h,j,l=[])=>{const m=c[j];if(isNothing(m))throw TypeError(`missing enumerator "${j}" at "${l.join(" > ")}"`);return m};class Enum extends Base$1{constructor(c,h=Enum,j=h.displayName){const l=Array.isArray(c)?c.reduce(enumeratorsReducer,{}):c;h!==Enum&&(h.displayName=j,Object.freeze(h)),super(h),Object.getOwnPropertyNames(l).forEach((m)=>{this[m]=always(l[m]),l[m][typeSymbol]=always(this),l[m].toJSON=always(m),l[m].equals=(o)=>l[m]===o}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:h,enumerators:l,reviver:reviverFactory$3(l)}))})}static fromObject(...c){return new Enum(...c)}static fromArray(...c){return new Enum(...c)}static innerTypes(){return emptyObject}}Object.defineProperty(Enum,"displayName",{value:"Enum",writable:!0});const set=(c,h,j,l)=>{const m=c.inner();return m.set(j,l),h.fromMap(m)},of=(c,h)=>{const j=h.length;if(1==j%2)throw TypeError(`${c.displayName}.of requires an even number of arguments`);const l=new Map;for(let m=0;m<j;m+=2)l.set(h[m],h[m+1]);return c.fromMap(l)},metadata$1=(c,h,j,l)=>{return Object.freeze({type:c,subtypes:Object.freeze([j,l]),reviver:h(j,l)})},equalPairs=(c,h)=>c.every((j,l)=>equals(j,h[l])),copy=(c)=>new Map(c);class AbstractMap extends Base$1{constructor(c,h=new Map,j){if(super(c),isNothing(h))throw TypeError("missing map");if(j&&0===h.size)return j;const l=copy(h);this[innerOrigSymbol]=always(l),this.inner=()=>copy(l),this.size=l.size}[Symbol.iterator](){return this[innerOrigSymbol]()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}get(c){return this[innerOrigSymbol]().get(c)}setIn(c,h){if(0===c.length)return new(this[typeSymbol]())(h);const[j,...l]=c,m=this[innerOrigSymbol]().get(j);return m.setIn?this.set(j,m.setIn(l,h)):this.set(j,h)}equals(c,h=!1){if(this===c)return!0;if(haveDifferentTypes(this,c)||this.size!==c.size)return!1;const j=this[Symbol.iterator](),l=c[Symbol.iterator]();for(let m=0;m<this.size;m+=1){const o=j.next().value,p=h?c.has(o[0])&&equals(o[1],c.get(o[0])):equalPairs(o,l.next().value);if(!p)return!1}return!0}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(c,h,j)=>(l,m)=>[c("",l[0],j.concat(m,0)),h("",l[1],j.concat(m,1))],reviverFactory$4=(c,h)=>(j,l,m=[])=>{if(""!==j)return l;const o=reviverOrAsIs(isFunction(c)?c(l,m):c),p=reviverOrAsIs(isFunction(h)?h(l,m):h),q=null===l?null:new Map(l.map(parseMapper(o,p,m)));return ModelicoMap.fromMap(q)};let EMPTY_MAP;class ModelicoMap extends AbstractMap$1{constructor(c){super(ModelicoMap,c,EMPTY_MAP),EMPTY_MAP||0!==this.size||(EMPTY_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMap"}set(c,h){return set(this,ModelicoMap,c,h)}toJSON(){return[...this]}static fromMap(c){return new ModelicoMap(c)}static fromArray(c){return ModelicoMap.fromMap(new Map(c))}static of(...c){return of(ModelicoMap,c)}static fromObject(c){return ModelicoMap.fromArray(objToArr(c))}static metadata(c,h){return metadata$1(ModelicoMap,reviverFactory$4,c,h)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_MAP||ModelicoMap.of()}}ModelicoMap.displayName="ModelicoMap";var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(c,h)=>{return c[h[0]]=h[1],c},parseReducer=(c,h,j)=>(l,m)=>[...l,[m,c("",h[m],j.concat(m))]],reviverFactory$5=(c)=>(h,j,l=[])=>{if(""!==h)return j;const m=reviverOrAsIs(isFunction(c)?c(j,l):c),o=null===j?null:new Map(Object.keys(j).reduce(parseReducer(m,j,l),[]));return StringMap.fromMap(o)};let EMPTY_STRING_MAP;class StringMap extends AbstractMap$1{constructor(c){super(StringMap,c,EMPTY_STRING_MAP),EMPTY_STRING_MAP||0!==this.size||(EMPTY_STRING_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoStringMap"}set(c,h){return set(this,StringMap,c,h)}toJSON(){return[...this].reduce(stringifyReducer,{})}static fromMap(c){return new StringMap(c)}static fromArray(c){return StringMap.fromMap(new Map(c))}static of(...c){return of(StringMap,c)}static fromObject(c){return StringMap.fromArray(objToArr(c))}static metadata(c){return metadata$1(StringMap,reviverFactory$5,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_STRING_MAP||StringMap.of()}}StringMap.displayName="StringMap";var StringMap$1=Object.freeze(StringMap);const stringifyReducer$1=(c,h)=>{return c[h[0].toJSON()]=h[1],c},parseMapper$1=(c,h,j,l)=>(m)=>{const o=c("",m,l),p=h("",j[m],l.concat(m));return[o,p]},reviverFactory$6=(c,h)=>(j,l,m=[])=>{if(""!==j)return l;const o=reviverOrAsIs(isFunction(c)?c(l,m):c),p=reviverOrAsIs(isFunction(h)?h(l,m):h),q=null===l?null:new Map(Object.keys(l).map(parseMapper$1(o,p,l,m)));return new EnumMap(q)};let EMPTY_ENUM_MAP;class EnumMap extends AbstractMap$1{constructor(c){super(EnumMap,c,EMPTY_ENUM_MAP),EMPTY_ENUM_MAP||0!==this.size||(EMPTY_ENUM_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoEnumMap"}set(c,h){return set(this,EnumMap,c,h)}toJSON(){return[...this].reduce(stringifyReducer$1,{})}static fromMap(c){return new EnumMap(c)}static fromArray(c){return EnumMap.fromMap(new Map(c))}static of(...c){return of(EnumMap,c)}static metadata(c,h){return metadata$1(EnumMap,reviverFactory$6,c,h)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_ENUM_MAP||EnumMap.of()}}EnumMap.displayName="EnumMap";var EnumMap$1=Object.freeze(EnumMap);const reviver=(c,h)=>{return ModelicoNumber.of(h)};class ModelicoNumber extends Base$1{constructor(c=0){if(super(ModelicoNumber),!_NumberisNaN(c)&&isNothing(c))throw TypeError("missing number");this.inner=always(+c),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoNumber"}set(){unsupported("Number.set is not supported")}setIn(c,h){return 0===c.length?ModelicoNumber.of(h):void unsupported("ModelicoNumber.setIn is not supported for non-empty paths")}toJSON(){const c=this.inner();return Object.is(c,-0)?"-0":c===Infinity?"Infinity":c===-Infinity?"-Infinity":_NumberisNaN(c)?"NaN":c}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&haveSameValues(this.inner(),c.inner())}static of(c){return new ModelicoNumber(c)}static metadata(){return Object.freeze({type:ModelicoNumber,reviver})}static innerTypes(){return emptyObject}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(c,h)=>{const j=null===h?null:new Date(h);return new ModelicoDate(j)};class ModelicoDate extends Base$1{constructor(c=new Date){if(super(ModelicoDate),isNothing(c))throw TypeError("missing date");const h=new Date(c.getTime());this.inner=()=>new Date(h.getTime()),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoDate"}set(){unsupported("Date.set is not supported")}setIn(c,h){return 0===c.length?ModelicoDate.of(h):void unsupported("Date.setIn is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.toJSON()===c.toJSON()}static of(c){return new ModelicoDate(c)}static metadata(){return Object.freeze({type:ModelicoDate,reviver:reviver$1})}static innerTypes(){return emptyObject}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(c,h)=>(j,l,m=[])=>{if(""!==j)return l;const o=Array.isArray(h);if(o&&l.length!==h.length)throw TypeError("tuple has missing or extra items");const p=o?(s)=>isFunction(h[s])?h[s](l,m):h[s]:isFunction(h)?always(h(l,m)):always(h),r=null===l?null:l.map((s,t)=>reviverOrAsIs(p(t))("",s,m.concat(t)));return new c(r)},iterableMetadata=(c,h)=>{return Object.freeze({type:c,subtypes:Object.freeze([h]),reviver:iterableReviverFactory(c,h)})},iterableEquals=(c,h,j=!1)=>{if(c===h)return!0;if(haveDifferentTypes(c,h)||c.size!==h.size)return!1;const l=c[Symbol.iterator](),m=h[Symbol.iterator]();for(let o=0;o<c.size;o+=1){const p=l.next().value;if(j){if(!h.has(p))return!1;}else if(!equals(p,m.next().value))return!1}return!0};let EMPTY_LIST;class List extends Base$1{constructor(c=[]){if(super(List),isNothing(c))throw TypeError("missing list");return EMPTY_LIST&&0===c.length?EMPTY_LIST:void(Object.freeze(c),this.inner=always(c),this[innerOrigSymbol]=this.inner,this.size=c.length,!EMPTY_LIST&&0===this.size&&(EMPTY_LIST=this),Object.freeze(this))}get[Symbol.toStringTag](){return"ModelicoList"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}includes(...c){return this.inner().includes(...c)}get(c){return this.inner()[c]}set(c,h){const j=[...this];return j[c]=h,List.fromArray(j)}setIn(c,h){if(0===c.length)return List.fromArray(h);const[j,...l]=c,m=this.inner()[j];return m.setIn?this.set(j,m.setIn(l,h)):this.set(j,h)}toJSON(){return this.inner()}equals(c){return iterableEquals(this,c)}static fromArray(c){return new List(c)}static of(...c){return List.fromArray(c)}static metadata(c){return iterableMetadata(List,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_LIST||List.of()}}List.displayName="List";var List$1=Object.freeze(List);let EMPTY_SET;const copy$1=(c)=>new Set(c);class ModelicoSet extends Base$1{constructor(c=new Set){if(super(ModelicoSet),isNothing(c))throw TypeError("missing set");if(EMPTY_SET&&0===c.size)return EMPTY_SET;const h=copy$1(c);this[innerOrigSymbol]=always(h),this.inner=()=>copy$1(h),this.size=h.size,EMPTY_SET||0!==this.size||(EMPTY_SET=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoSet"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}set(){unsupported("Set.set is not supported")}setIn(c,h){return 0===c.length?new ModelicoSet(h):void unsupported("Set.setIn is not supported for non-empty paths")}toJSON(){return[...this]}equals(...c){return iterableEquals(this,...c)}static fromSet(c){return new ModelicoSet(c)}static fromArray(c){return ModelicoSet.fromSet(new Set(c))}static of(...c){return ModelicoSet.fromArray(c)}static metadata(c){return iterableMetadata(ModelicoSet,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_SET||ModelicoSet.of()}}ModelicoSet.displayName="ModelicoSet";var ModelicoSet$1=Object.freeze(ModelicoSet);const proxyToSelf=(c,h,j,l,m)=>{return c.includes(m)?(...o)=>{const p=l[m](...o);return proxyFactory(c,h,j,p)}:l[m]},proxyToInner=(c,h,j,l,m,o,p)=>{return j.includes(p)?(...q)=>{const r=o.setIn([],h.apply(c,q));return proxyFactory(j,l,m,r)}:l.includes(p)?(...q)=>{h.apply(c,q);const r=o.setIn([],c);return proxyFactory(j,l,m,r)}:(...q)=>{return h.apply(c,q)}},proxyFactory=(c,h,j,l)=>{return new Proxy(l,{get:(o,p)=>{if(p in o)return proxyToSelf(c,h,j,o,p);const q=j(o.inner()),r=q[p];return"function"==typeof r?proxyToInner(q,r,c,h,j,o,p):r}})},formatError=(c,h,j,l=[])=>["Invalid JSON at \""+l.join(" > ")+"\". According to the schema\n",JSON.stringify(h,null,2)+"\n","the value (data path \""+c.errors.filter((m)=>""!==m.dataPath).map((m)=>m.dataPath)+"\")\n",JSON.stringify(j,null,2)+"\n"].concat(c.errors.map((m)=>m.message)).join("\n"),formatDefaultValueError=(c,h,j)=>["Invalid default value. According to the schema\n",JSON.stringify(h,null,2)+"\n","the default value\n",JSON.stringify(j,null,2)+"\n"].concat(c.errors.map((l)=>l.message)).join("\n");var ajvMetadata=(c={validate:T})=>{const h=M.metadata(),j={},{_:l,base:m,asIs:o,any:p,anyOf:q,string:r,number:s,boolean:t,date:u,enumMap:w,list:y,map:z,stringMap:A,set:B,maybe:C,withDefault:D}=h,E=(J,K,L=identity)=>(N,O,P)=>{if(""!==N)return O;const Q=K===emptyObject||c.validate(K,L(O));if(!Q)throw TypeError(formatError(c,K,O,P));const R=isFunction(J)?J(O,P):J;return R.reviver("",O,P)},F=(J,K,L)=>(N,O)=>{if(""!==N)return O;const P=E(J,K)(N,O);return E(p(),L,(Q)=>Q.inner())(N,P)},G=(J,K,L=emptyObject,N=always(emptyObject))=>{const O=K===emptyObject&&L===emptyObject?emptyObject:Object.assign({},K,L),P=E(J,O),R=isFunction(J)?{type:J}:J;return Object.assign({},R,{reviver:P,ownSchema:always(O),schema:()=>Object.assign({},O,N())})};j.ajvMeta=G,j.ajv_=(J,K=emptyObject,L)=>{const N=l(J,L);return G(N,emptyObject,K,()=>getSchema(N,!1))},j.ajvBase=(J,K=emptyObject)=>{const L=m(J);return G(L,{type:"object"},K,()=>getSchema(L,!1))},j.ajvAsIs=(J,K=identity)=>G(o(K),J),j.ajvAny=(J)=>j.ajvAsIs(J),j.ajvNumber=(J,K=emptyObject)=>{const{wrap:L=!1}=K,N=s(K);if(!L)return G(N,{type:"number"},J);const O=Object.assign({type:"number"},J),P=F(N,{anyOf:[{type:"number"},{type:"string",enum:["-0","-Infinity","Infinity","NaN"]}]},O);return Object.assign({},N,{reviver:P,ownSchema:always(O),schema:always(O)})},j.ajvString=(J)=>G(r(),{type:"string"},J),j.ajvBoolean=(J)=>G(t(),{type:"boolean"},J),j.ajvDate=(J)=>G(u(),{type:"string",format:"date-time"},J),j.ajvEnum=(J)=>{const K=l(J);return G(K,{type:"string",enum:Object.keys(K.enumerators)})},j.ajvEnumMap=(J,K,L)=>{const N=Object.keys(K.enumerators),O=`^(${N.join("|")})$`;return G(w(K,L),{type:"object",maxProperties:N.length,additionalProperties:!1,patternProperties:{[O]:{}}},J,()=>({patternProperties:{[O]:getSchema(L,!1)}}))};const H=(J,K)=>G(y(K),{type:"array"},J,()=>({items:getSchema(K,!1)})),I=(J,K)=>{const L=K.length;return G(y(K),{type:"array",minItems:L,maxItems:L},J,()=>({items:K.map((N)=>getSchema(N,!1))}))};return j.ajvList=(J,K)=>Array.isArray(K)?I(J,K):H(J,K),j.ajvMap=(J,K,L)=>{const N={type:"array",items:{type:"array",minItems:2,maxItems:2}};return G(z(K,L),N,J,()=>({items:Object.assign({items:[getSchema(K,!1),getSchema(L,!1)]},N.items)}))},j.ajvStringMap=(J,K)=>G(A(K),{type:"object"},J,()=>({additionalProperties:!1,patternProperties:{".*":getSchema(K,!1)}})),j.ajvSet=(J,K)=>G(B(K),{type:"array",uniqueItems:!0},J,()=>({items:getSchema(K,!1)})),j.ajvMaybe=(J)=>G(C(J),emptyObject,emptyObject,()=>getSchema(J,!1)),j.ajvWithDefault=(J,K)=>{const L=getSchema(J,!1),N=c.validate(L,K);if(!N)throw TypeError(formatDefaultValueError(c,L,K));return G(D(J,K),{default:K},emptyObject,always(L))},j.ajvAnyOf=(J,K)=>G(q(J,K),{anyOf:J.map((L)=>getSchema(L[0],!1))}),Object.freeze(Object.assign(j,h))},asIs=(c=identity)=>Object.freeze({type:c,reviver:asIsReviver(pipe(assertSomethingIdentity,c)),maybeReviver:asIsReviver(c)}),any=always(asIs(identity)),anyOf=(c=[],h="type")=>(j,l)=>{if(0===c.length)return any;const m=c[0][1][typeSymbol](),o=m.metadata().reviver("",j[h]);for(let q=0;q<c.length;q+=1){const r=c[q],s=r[0],t=r[1];if(o===t)return s}const p=l.slice(0,-1);throw TypeError(`unsupported enumerator "${o.toJSON()}" at "${p.join(" > ")}"`)};const internalNonMutators=["set","setIn"],mapNonMutators=internalNonMutators,mapMutators=["delete","clear"],setNonMutators=internalNonMutators,setMutators=["add","delete","clear"],listNonMutators=internalNonMutators.concat(["concat","slice","filter"]),listMutators=["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],metadataCache=new WeakMap,base=(c)=>Object.freeze({type:c,reviver:reviverFactory(c)}),raw_=(c,h)=>c.metadata?c.metadata(...h):base(c),_=(c,h=[])=>{return 0<h.length?raw_(c,h):(metadataCache.has(c)||metadataCache.set(c,raw_(c,h)),metadataCache.get(c))},metadata=()=>Object.freeze({_,base,asIs,any,anyOf,number:({wrap:c=!1}={})=>c?ModelicoNumber$1.metadata():asIs(Number),string:always(asIs(String)),boolean:always(asIs(Boolean)),date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$1.metadata,map:ModelicoMap$1.metadata,stringMap:StringMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata,withDefault:(c,h)=>{const j=reviverOrAsIs(c)("",h);return Object.freeze(Object.assign({},c,{default:j}))}}),proxyMap=partial(proxyFactory,mapNonMutators,mapMutators,identity),genericsFromJS=(c,h,j)=>_(c,h).reviver("",j),fromJS=(c,h)=>genericsFromJS(c,[],h),ajvGenericsFromJS=(c,h,j,l,m)=>c(h,j,l).reviver("",m),ajvFromJS=(c,h,j,l)=>ajvGenericsFromJS(c,h,j,[],l),createModel=(c,h="ModelicoModel")=>{return class extends Base$1{get[Symbol.toStringTag](){return h}static innerTypes(j,l){return"function"==typeof c?c(j,l):Object.freeze(c)}}};var M={about:Object.freeze({version,author,homepage,license}),Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum,EnumMap:EnumMap$1,List:List$1,Map:ModelicoMap$1,StringMap:StringMap$1,Maybe:Maybe$1,Base:Base$1,Set:ModelicoSet$1,createModel,fields:(c)=>c[fieldsSymbol](),symbols,fromJS,genericsFromJS,fromJSON:(c,h)=>fromJS(c,JSON.parse(h)),genericsFromJSON:(c,h,j)=>genericsFromJS(c,h,JSON.parse(j)),ajvFromJS,ajvGenericsFromJS,ajvFromJSON:(c,h,j,l)=>ajvFromJS(c,h,j,JSON.parse(l)),ajvGenericsFromJSON:(c,h,j,l,m)=>ajvGenericsFromJS(c,h,j,l,JSON.parse(m)),metadata,ajvMetadata,getSchema,validate,withValidation,proxyMap,proxyEnumMap:proxyMap,proxyStringMap:proxyMap,proxyList:partial(proxyFactory,listNonMutators,listMutators,(c)=>[...c]),proxySet:partial(proxyFactory,setNonMutators,setMutators,identity),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators,identity)};export default M;

