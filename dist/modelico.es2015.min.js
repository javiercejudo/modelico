import Immutable from"immutable";var version="19.0.5",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico/tree/immutable-js#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),get=(c/* : string */)=>(e/* : Object */)=>e[c],pipe2=(c/* : Function */,e/* : Function */)=>(...g/* : Array<mixed> */)=>e(c(...g)),not=(c/* : boolean */)=>/* : boolean */!c,identity=/* :: <T> */(c/* : T */)=>/* : T */c,partial=(c/* : Function */,...e/* : Array<mixed> */)=>c.bind(void 0,...e),asIsReviver=(c/* : Function */)=>(e/* : string */,g/* : mixed */)=>c(g),always=/* :: <T> */(c/* : T */)=>()=>/* : T */c,isNothing=(c/* : mixed */)=>/* : boolean */null==c||Number.isNaN(c),isSomething=pipe2(isNothing,not),defaultTo=(c/* : mixed */)=>(e/* : mixed */)=>isNothing(e)?c:e,objToArr=(c/* : Object */)=>Object.keys(c).map(e=>[e,c[e]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(identity))),isPlainObject=(c/* : mixed */)=>/* : boolean */"object"==typeof c&&!!c,emptyObject=Object.freeze({}),haveSameValues=(c/* : any */,e/* : any */)=>/* : boolean */c===e||Object.is(c,e),haveSameType=(c/* : any */,e/* : any */)=>/* : boolean */null==c||null==e?c===e:c.constructor===e.constructor,haveDifferentTypes=pipe2(haveSameType,not),equals=(c/* : any */,e/* : any */)=>/* : boolean */isSomething(c)&&c.equals?c.equals(e):haveSameValues(c,e),getInnerTypes=(c/* : number */,e/* : Function */)=>{if(!e.innerTypes)throw Error(`missing static innerTypes for ${e.displayName||e.name}`);return e.innerTypes(c+1,e)},unsupported=(c/* : string */)=>{throw Error(c)},innerTypesCache=new WeakMap,getInnerTypesWithCache=(c,e)=>{return innerTypesCache.has(e)||innerTypesCache.set(e,getInnerTypes(c,e)),innerTypesCache.get(e)},plainObjectReviverFactory=(c,e,g,h)=>Object.keys(h).reduce((j,l)=>{const m=getInnerTypesWithCache(c,e),o=m[l];return j[l]=o?reviverOrAsIs(o)(g,h[l]):h[l],j},{}),reviverFactory=(c,e)=>(g,h)=>{if(""!==g)return h;const j=isPlainObject(h)?plainObjectReviverFactory(c,e,g,h):h;return new e(j)};// @flow
class Base{constructor(c,e=emptyObject,g){if(!isPlainObject(e))throw TypeError(`expected an object with fields for ${c.displayName||c.name} but got ${e}`);Object.freeze(e);const h=getInnerTypes(0,c);g=defaultTo(this)(g),g[typeSymbol]=always(c),g[fieldsSymbol]=always(e),Object.keys(h).forEach(j=>{const l=e[j];let m=M.Maybe.EMPTY;if(isSomething(l))m=l;else if(h[j].type!==M.Maybe)throw TypeError(`no value for key "${j}"`);g[j]=always(m)})}set(c,e){const g=Object.assign({},this[fieldsSymbol](),{[c]:e});return new(this[typeSymbol]())(g)}setPath(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const[g,...h]=c,j=this[g]();return j.setPath?this.set(g,j.setPath(h,e)):this.set(g,e)}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&JSON.stringify(this)===JSON.stringify(c)}toJSON(){return this[fieldsSymbol]()}toJS(){return JSON.parse(JSON.stringify(this))}stringify(c){return JSON.stringify(this,null,c)}static factory(...c){return new Base(...c)}}var Base$1=Object.freeze(Base);const reviverFactory$2=c=>(e,g)=>{if(""!==e)return g;const h=null===g?null:c.reviver(e,g);return new Maybe(h)};class Nothing{toJSON(){return null}}class Just{constructor(c){this.get=always(c),Object.freeze(this)}toJSON(){const c=this.get();return isNothing(c)?null:c.toJSON?c.toJSON():c}}const nothing=new Nothing;class Maybe extends Base$1{constructor(c,e=!0){super(Maybe);const g=e&&isNothing(c)?nothing:new Just(c);this.inner=always(g),Object.freeze(this)}set(c,e){if(this.isEmpty())return this;const g=this.inner().get();if(isNothing(g))return this;const h=g.set?g.set(c,e):null;return new Maybe(h)}setPath(c,e){if(0===c.length)return Maybe.of(e);if(this.isEmpty())return this;const g=this.inner().get();if(isNothing(g))return this;const h=g.setPath?g.setPath(c,e):null;return Maybe.of(h)}isEmpty(){return this.inner()===nothing}getOrElse(c){return this.isEmpty()?c:this.inner().get()}map(c){return this.isEmpty()?this:Maybe.ofAny(c(this.inner().get()))}toJSON(){return this.inner().toJSON()}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=this.inner(),g=c.inner();return this.isEmpty()||c.isEmpty()?e===g:equals(e.get(),g.get())}static of(c){return new Maybe(c)}static ofAny(c){return new Maybe(c,!1)}static metadata(c){return Object.freeze({type:Maybe,reviver:reviverFactory$2(c)})}static innerTypes(){return emptyObject}}Maybe.displayName="Maybe",Maybe.EMPTY=Maybe.of();var Maybe$1=Object.freeze(Maybe);const enumeratorsReducer=(c,e)=>Object.assign(c,{[e]:{code:e}}),reviverFactory$3=c=>(e,g)=>{const h=c[g];if(isNothing(h))throw TypeError(`missing enumerator (${g})`);return h};class Enum extends Base$1{constructor(c){const e=Array.isArray(c)?c.reduce(enumeratorsReducer,{}):c;super(Enum),Object.getOwnPropertyNames(e).forEach(g=>{this[g]=always(e[g]),e[g].toJSON=always(g)}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:Enum,reviver:reviverFactory$3(e)})),enumerable:!1}),Object.freeze(this)}static fromObject(c){return new Enum(c)}static fromArray(c){return new Enum(c)}static innerTypes(){return emptyObject}}Enum.displayName="Enum";var Enum$1=Object.freeze(Enum);const set=(c,e,g,h)=>{const j=c.inner(),l=j.set(g,h);return j===l?c:e.fromArray([...l])},of=(c,e)=>{const g=e.length;if(1==g%2)throw TypeError(`${c.displayName||c.name}.of requires an even number of arguments`);const h=[];for(let j=0;j<g;j+=2)h.push([e[j],e[j+1]]);return c.fromArray(h)},metadata$1=(c,e)=>{return Object.freeze({type:c,reviver:e})};class AbstractMap extends Base$1{constructor(c,e){if(super(c),isNothing(e))throw TypeError("missing map");const g=Immutable.OrderedMap(e);this.inner=always(g),this.size=g.size,this[Symbol.iterator]=()=>g[Symbol.iterator]()}setPath(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const[g,...h]=c,j=this.inner().get(g);return j.setPath?this.set(g,j.setPath(h,e)):this.set(g,e)}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.inner().equals(c.inner())}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(c,e)=>g=>{const h=c("",g[0]),j=e("",g[1]);return[h,j]},reviverFactory$4=(c,e)=>(g,h)=>{if(""!==g)return h;const j=reviverOrAsIs(c),l=reviverOrAsIs(e),m=null===h?null:new Map(h.map(parseMapper(j,l)));return ModelicoMap.fromMap(m)};class ModelicoMap extends AbstractMap$1{constructor(c){super(ModelicoMap,c),Object.freeze(this)}set(c,e){return set(this,ModelicoMap,c,e)}toJSON(){return[...this]}static fromMap(c){return new ModelicoMap(c)}static fromArray(c){return ModelicoMap.fromMap(new Map(c))}static of(...c){return of(ModelicoMap,c)}static fromObject(c){return ModelicoMap.fromArray(objToArr(c))}static metadata(c,e){return metadata$1(ModelicoMap,reviverFactory$4(c,e))}static innerTypes(){return emptyObject}}ModelicoMap.displayName="ModelicoMap",ModelicoMap.EMPTY=ModelicoMap.of();var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(c,e)=>{return c[e[0]]=e[1],c},parseReducer=(c,e)=>(g,h)=>[...g,[h,c("",e[h])]],reviverFactory$5=c=>(e,g)=>{if(""!==e)return g;const h=reviverOrAsIs(c),j=null===g?null:new Map(Object.keys(g).reduce(parseReducer(h,g),[]));return StringMap.fromMap(j)};class StringMap extends AbstractMap$1{constructor(c){super(StringMap,c),Object.freeze(this)}set(c,e){return set(this,StringMap,c,e)}toJSON(){return[...this].reduce(stringifyReducer,{})}static fromMap(c){return new StringMap(c)}static fromArray(c){return StringMap.fromMap(new Map(c))}static of(...c){return of(StringMap,c)}static fromObject(c){return StringMap.fromArray(objToArr(c))}static metadata(c){return metadata$1(StringMap,reviverFactory$5(c))}static innerTypes(){return emptyObject}}StringMap.displayName="StringMap",StringMap.EMPTY=StringMap.of();var StringMap$1=Object.freeze(StringMap);const stringifyReducer$1=(c,e)=>{return c[e[0].toJSON()]=e[1],c},parseMapper$1=(c,e,g)=>h=>{const j=c("",h),l=e("",g[h]);return[j,l]},reviverFactory$6=(c,e)=>(g,h)=>{if(""!==g)return h;const j=reviverOrAsIs(c),l=reviverOrAsIs(e),m=null===h?null:new Map(Object.keys(h).map(parseMapper$1(j,l,h)));return new EnumMap(m)};class EnumMap extends AbstractMap$1{constructor(c){super(EnumMap,c),Object.freeze(this)}set(c,e){return set(this,EnumMap,c,e)}toJSON(){return[...this].reduce(stringifyReducer$1,{})}static fromMap(c){return new EnumMap(c)}static fromArray(c){return EnumMap.fromMap(new Map(c))}static of(...c){return of(EnumMap,c)}static metadata(c,e){return metadata$1(EnumMap,reviverFactory$6(c,e))}static innerTypes(){return emptyObject}}EnumMap.displayName="EnumMap",EnumMap.EMPTY=EnumMap.of();var EnumMap$1=Object.freeze(EnumMap);const reviver=(c,e)=>{return ModelicoNumber.of(e)};class ModelicoNumber extends Base$1{constructor(c){if(super(ModelicoNumber),!Number.isNaN(c)&&isNothing(c))throw TypeError("missing number");this.inner=always(+c),Object.freeze(this)}set(){unsupported("Number.set is not supported")}setPath(c,e){return 0===c.length?ModelicoNumber.of(e):void unsupported("ModelicoNumber.setPath is not supported for non-empty paths")}toJSON(){const c=this.inner();return Object.is(c,-0)?"-0":c===1/0?"Infinity":c===-(1/0)?"-Infinity":Number.isNaN(c)?"NaN":c}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&haveSameValues(this.inner(),c.inner())}static of(c){return new ModelicoNumber(c)}static metadata(){return Object.freeze({type:ModelicoNumber,reviver})}static innerTypes(){return emptyObject}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(c,e)=>{const g=null===e?null:new Date(e);return new ModelicoDate(g)};class ModelicoDate extends Base$1{constructor(c){if(super(ModelicoDate),isNothing(c))throw TypeError("missing date");const e=new Date(c.getTime());this.inner=()=>new Date(e.getTime()),Object.freeze(this)}set(){unsupported("Date.set is not supported")}setPath(c,e){return 0===c.length?ModelicoDate.of(e):void unsupported("Date.setPath is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.toJSON()===c.toJSON()}static of(c){return new ModelicoDate(c)}static metadata(){return Object.freeze({type:ModelicoDate,reviver:reviver$1})}static innerTypes(){return emptyObject}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(c,e)=>(g,h)=>{if(""!==g)return h;const j=partial(reviverOrAsIs(e),g),l=null===h?null:h.map(j);return new c(l)},iterableMetadata=(c,e)=>{return Object.freeze({type:c,reviver:iterableReviverFactory(c,e)})},iterableEquals=(c,e)=>{return!(c!==e)||!haveDifferentTypes(c,e)&&c.inner().equals(e.inner())};class List extends Base$1{constructor(c){if(super(List),isNothing(c))throw TypeError("missing list");Object.freeze(c);const e=Immutable.List(c);this.inner=always(e),this.size=e.size,this[Symbol.iterator]=()=>e[Symbol.iterator](),Object.freeze(this)}set(c,e){const g=[...this.inner().set(c,e)];return List.fromArray(g)}setPath(c,e){if(0===c.length)return List.fromArray(e);const[g,...h]=c,j=this.inner().get(g);return j.setPath?this.set(g,j.setPath(h,e)):this.set(g,e)}toJSON(){return[...this.inner()]}equals(c){return iterableEquals(this,c)}static fromArray(c){return new List(c)}static of(...c){return List.fromArray(c)}static metadata(c){return iterableMetadata(List,c)}static innerTypes(){return emptyObject}}List.displayName="List",List.EMPTY=List.of();var List$1=Object.freeze(List);class ModelicoSet extends Base$1{constructor(c){if(super(ModelicoSet),isNothing(c))throw TypeError("missing set");const e=Immutable.OrderedSet(c);this.inner=always(e),this.size=e.size,this[Symbol.iterator]=()=>e[Symbol.iterator](),Object.freeze(this)}set(){unsupported("Set.set is not supported")}setPath(c,e){return 0===c.length?new ModelicoSet(e):void unsupported("Set.setPath is not supported for non-empty paths")}toJSON(){return[...this]}equals(c){return iterableEquals(this,c)}static fromSet(c){return new ModelicoSet(c)}static fromArray(c){return ModelicoSet.fromSet(new Set(c))}static of(...c){return ModelicoSet.fromArray(c)}static metadata(c){return iterableMetadata(ModelicoSet,c)}static innerTypes(){return emptyObject}}ModelicoSet.displayName="ModelicoSet",ModelicoSet.EMPTY=ModelicoSet.of();var ModelicoSet$1=Object.freeze(ModelicoSet);const Any=c=>identity(c);var Any$1=Object.freeze(Any);const proxyToSelf=(c,e,g,h,j)=>{return c.includes(j)?(...l)=>{const m=h[j](...l);return proxyFactory(c,e,g,m)}:h[j]},proxyToInner=(c,e,g,h,j,l,m)=>{return g.includes(m)?(...o)=>{const p=l.setPath([],e.apply(c,o));return proxyFactory(g,h,j,p)}:h.includes(m)?(...o)=>{e.apply(c,o);const p=l.setPath([],c);return proxyFactory(g,h,j,p)}:(...o)=>{return e.apply(c,o)}},proxyFactory=(c,e,g,h)=>{return new Proxy(h,{get:(j,l)=>{if(l in j)return proxyToSelf(c,e,g,j,l);const m=g(j.inner()),o=m[l];return"function"==typeof o?proxyToInner(m,o,c,e,g,j,l):o}})};var asIs=(c=Any$1)=>Object.freeze({type:c,reviver:asIsReviver(c)});const internalNonMutators=["set","setPath"],mapNonMutators=internalNonMutators,mapMutators=[],setNonMutators=internalNonMutators,setMutators=[],listNonMutators=internalNonMutators.concat(["delete","insert","clear","push","pop","unshift","shift","update","merge","mergeWith","mergeDeep","mergeDeepWith","map","filter","filterNot","reverse","sort","sortBy","slice","rest","butLast","skip","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","concat"]),listMutators=[],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],_=function(c,e=0,g=[]){return c.metadata?c.metadata(...g):Object.freeze({type:c,reviver:reviverFactory(e,c)})},metadata=Object.freeze({_,asIs,any:always(asIs(Any$1)),number:({wrap:c=!1}={})=>c?ModelicoNumber$1.metadata():asIs(Number),string:always(asIs(String)),boolean:always(asIs(Boolean)),regExp:always(asIs(RegExp)),fn:always(asIs(Function)),date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$1.metadata,map:ModelicoMap$1.metadata,stringMap:StringMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata});var M={about:Object.freeze({version,author,homepage,license}),Any:Any$1,Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum:Enum$1,EnumMap:EnumMap$1,List:List$1,Map:ModelicoMap$1,StringMap:StringMap$1,Maybe:Maybe$1,Base:Base$1,Set:ModelicoSet$1,fields:c=>c[fieldsSymbol](),fromJSON:(c,e)=>JSON.parse(e,_(c).reviver),genericsFromJSON:(c,e,g)=>JSON.parse(g,_(c,0,e).reviver),metadata,proxyMap:partial(proxyFactory,mapNonMutators,mapMutators,identity),proxyEnumMap:partial(proxyFactory,mapNonMutators,mapMutators,identity),proxyList:partial(proxyFactory,listNonMutators,listMutators,identity),proxySet:partial(proxyFactory,setNonMutators,setMutators,identity),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators,identity)};export default M;

