var version="20.0.0",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),innerOrigSymbol=Symbol("innerOrigSymbol");var symbols=Object.freeze({typeSymbol:typeSymbol,fieldsSymbol:fieldsSymbol,innerOrigSymbol:innerOrigSymbol});const get=(c)=>(e)=>e[c],pipe2=(c,e)=>(...h)=>e(c(...h)),not=(c)=>!c,T=()=>!0,identity=(c)=>c,partial=(c,...e)=>c.bind(void 0,...e),asIsReviver=(c)=>(e,h)=>c(h),always=(c)=>()=>c,isNothing=(c)=>null==c||Number.isNaN(c),isSomething=pipe2(isNothing,not),defaultTo=(c)=>(e)=>isNothing(e)?c:e,objToArr=(c)=>Object.keys(c).map(e=>[e,c[e]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(identity))),isPlainObject=(c)=>"object"==typeof c&&!!c,emptyObject=Object.freeze({}),haveSameValues=(c,e)=>c===e||Object.is(c,e),haveSameType=(c,e)=>null==c||null==e?c===e:c.constructor===e.constructor,haveDifferentTypes=pipe2(haveSameType,not),equals=(c,e)=>isSomething(c)&&c.equals?c.equals(e):haveSameValues(c,e),unsupported=(c)=>{throw Error(c)},innerTypesCache=new WeakMap,getInnerTypes=(c,e)=>{if(!e.innerTypes)throw Error(`missing static innerTypes for ${e.displayName||e.name}`);return e.innerTypes(c,e)};var getInnerTypes$1=(c,e)=>{return innerTypesCache.has(e)||innerTypesCache.set(e,getInnerTypes(c,e)),innerTypesCache.get(e)};const plainObjectReviverFactory=(c,e,h,j)=>Object.keys(h).reduce((l,m)=>{const o=j.concat(m),p=getInnerTypes$1(o,c),q=p[m];return l[m]=q?reviverOrAsIs(q)(e,h[m],o):h[m],l},{}),reviverFactory=(c,e)=>(h,j)=>{if(""!==h)return j;const l=isPlainObject(j)?plainObjectReviverFactory(e,h,j,c):j;return new e(l)};var getSchema=c=>{if(c.schema)return c.schema;const e={type:"object"};if(!c.type.innerTypes||0===Object.keys(getInnerTypes$1([],c.type)).length)return e;const h=c.type.innerTypes(),j=[],l=Object.keys(h).reduce((o,p)=>{const q=h[p],r=q.schema;return q.type!==M.Maybe&&void 0===q.default&&j.push(p),Object.assign(o,{[p]:r})},{}),m=Object.assign({},e,{properties:l});return 0<j.length&&(m.required=j),m},withValidation=(c,e,h=(l,m)=>`Invalid value at ${m.join(" > ")}`)=>{return Object.assign({},c,{reviver:(l,m,o=[])=>{if(""!==l)return m;const p=c.reviver("",m,o);if(!e(p))throw TypeError(h(p,o));return p}})};const getPathReducer=(c,e)=>c.get(e);class Base{constructor(c,e=emptyObject,h){if(!isPlainObject(e))throw TypeError(`expected an object with fields for ${c.displayName||c.name} but got ${e}`);Object.freeze(e);const j={},l=getInnerTypes$1([],c);h=defaultTo(this)(h),h[typeSymbol]=always(c),Object.keys(l).forEach(m=>{const o=e[m];let p=M.Maybe.EMPTY;if(isSomething(o))p=o;else if(isSomething(l[m].default))p=l[m].default,j[m]=p;else if(l[m].type!==M.Maybe)throw TypeError(`no value for key "${m}"`);else j[m]=p;h[m]=always(p)}),h[fieldsSymbol]=always(Object.freeze(Object.assign(j,e)))}get(c){return this[fieldsSymbol]()[c]}getIn(c){return c.reduce(getPathReducer,this)}set(c,e){const h=Object.assign({},this[fieldsSymbol](),{[c]:e});return new(this[typeSymbol]())(h)}setIn(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const[h,...j]=c,l=this[h]();return l.setIn?this.set(h,l.setIn(j,e)):this.set(h,e)}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=this[fieldsSymbol](),h=c[fieldsSymbol](),j=Object.keys(e),l=Object.keys(h);return!(j.length!==l.length)&&j.every(m=>equals(e[m],h[m]))}toJSON(){return this[fieldsSymbol]()}toJS(){return JSON.parse(JSON.stringify(this))}stringify(c){return JSON.stringify(this,null,c)}static factory(...c){return new Base(...c)}}var Base$1=Object.freeze(Base);const reviverFactory$2=c=>(e,h,j)=>{if(""!==e)return h;const l=null===h?null:c.reviver(e,h,j);return new Maybe(l)};class Nothing{toJSON(){return null}}class Just{constructor(c){this.get=always(c),Object.freeze(this)}toJSON(){const c=this.get();return isNothing(c)?null:c.toJSON?c.toJSON():c}}const nothing=new Nothing;class Maybe extends Base$1{constructor(c,e=!0){super(Maybe);const h=e&&isNothing(c)?nothing:new Just(c);this.inner=always(h),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMaybe"}get(c){const e=c[0],h=c[1],j=this.getOrElse(e);return j.get?j.get(h):j}set(c,e){if(this.isEmpty())return this;const h=this.inner().get();if(isNothing(h))return this;const j=h.set?h.set(c,e):null;return new Maybe(j)}setIn(c,e){if(0===c.length)return Maybe.of(e);const[h,...j]=c,l=h[0],m=h[1],o=this.isEmpty()?l:this.inner().get(),p=o.setIn?o.setIn([m,...j],e):null;return Maybe.of(p)}isEmpty(){return this.inner()===nothing}getOrElse(c){return this.isEmpty()?c:this.inner().get()}map(c){return this.isEmpty()?this:Maybe.ofAny(c(this.inner().get()))}toJSON(){return this.inner().toJSON()}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=this.inner(),h=c.inner();return this.isEmpty()||c.isEmpty()?e===h:equals(e.get(),h.get())}static of(c){return new Maybe(c)}static ofAny(c){return new Maybe(c,!1)}static metadata(c){return Object.freeze({type:Maybe,subtypes:[c],reviver:reviverFactory$2(c)})}static innerTypes(){return emptyObject}}Maybe.displayName="Maybe",Maybe.EMPTY=Maybe.of();var Maybe$1=Object.freeze(Maybe);const enumeratorsReducer=(c,e)=>Object.assign(c,{[e]:{code:e}}),reviverFactory$3=c=>(e,h,j=[])=>{const l=c[h];if(isNothing(l))throw TypeError(`missing enumerator "${h}" at "${j.join(" > ")}"`);return l};class Enum extends Base$1{constructor(c,e=Enum,h=e.displayName){const j=Array.isArray(c)?c.reduce(enumeratorsReducer,{}):c;e!==Enum&&(e.displayName=h,Object.freeze(e)),super(e),Object.getOwnPropertyNames(j).forEach(l=>{this[l]=always(j[l]),j[l].toJSON=always(l),j[l].equals=m=>j[l]===m}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:e,reviver:reviverFactory$3(j)}))})}static fromObject(...c){return new Enum(...c)}static fromArray(...c){return new Enum(...c)}static innerTypes(){return emptyObject}}Object.defineProperty(Enum,"displayName",{value:"Enum",writable:!0});const set=(c,e,h,j)=>{const l=c.inner();return l.set(h,j),e.fromMap(l)},of=(c,e)=>{const h=e.length;if(1==h%2)throw TypeError(`${c.displayName}.of requires an even number of arguments`);const j=new Map;for(let l=0;l<h;l+=2)j.set(e[l],e[l+1]);return c.fromMap(j)},metadata$1=(c,e,h,j)=>{return Object.freeze({type:c,subtypes:Object.freeze([h,j]),reviver:e(h,j)})},equalPairs=(c,e)=>c.every((h,j)=>equals(h,e[j])),copy=c=>new Map(c);class AbstractMap extends Base$1{constructor(c,e=new Map,h){if(super(c),isNothing(e))throw TypeError("missing map");if(h&&0===e.size)return h;const j=copy(e);this[innerOrigSymbol]=always(j),this.inner=()=>copy(j),this.size=j.size}[Symbol.iterator](){return this[innerOrigSymbol]()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}get(c){return this[innerOrigSymbol]().get(c)}setIn(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const[h,...j]=c,l=this[innerOrigSymbol]().get(h);return l.setIn?this.set(h,l.setIn(j,e)):this.set(h,e)}equals(c,e=!1){if(this===c)return!0;if(haveDifferentTypes(this,c)||this.size!==c.size)return!1;const h=this[Symbol.iterator](),j=c[Symbol.iterator]();for(let l=0;l<this.size;l+=1){const m=h.next().value,o=e?c.has(m[0])&&equals(m[1],c.get(m[0])):equalPairs(m,j.next().value);if(!o)return!1}return!0}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(c,e,h)=>(j,l)=>[c("",j[0],h.concat(l,0)),e("",j[1],h.concat(l,1))],reviverFactory$4=(c,e)=>(h,j,l=[])=>{if(""!==h)return j;const m=reviverOrAsIs(c),o=reviverOrAsIs(e),p=null===j?null:new Map(j.map(parseMapper(m,o,l)));return ModelicoMap.fromMap(p)};let EMPTY_MAP;class ModelicoMap extends AbstractMap$1{constructor(c){super(ModelicoMap,c,EMPTY_MAP),EMPTY_MAP||0!==this.size||(EMPTY_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMap"}set(c,e){return set(this,ModelicoMap,c,e)}toJSON(){return[...this]}static fromMap(c){return new ModelicoMap(c)}static fromArray(c){return ModelicoMap.fromMap(new Map(c))}static of(...c){return of(ModelicoMap,c)}static fromObject(c){return ModelicoMap.fromArray(objToArr(c))}static metadata(c,e){return metadata$1(ModelicoMap,reviverFactory$4,c,e)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_MAP||ModelicoMap.of()}}ModelicoMap.displayName="ModelicoMap";var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(c,e)=>{return c[e[0]]=e[1],c},parseReducer=(c,e,h)=>(j,l)=>[...j,[l,c("",e[l],h.concat(l))]],reviverFactory$5=c=>(e,h,j=[])=>{if(""!==e)return h;const l=reviverOrAsIs(c),m=null===h?null:new Map(Object.keys(h).reduce(parseReducer(l,h,j),[]));return StringMap.fromMap(m)};let EMPTY_STRING_MAP;class StringMap extends AbstractMap$1{constructor(c){super(StringMap,c,EMPTY_STRING_MAP),EMPTY_STRING_MAP||0!==this.size||(EMPTY_STRING_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoStringMap"}set(c,e){return set(this,StringMap,c,e)}toJSON(){return[...this].reduce(stringifyReducer,{})}static fromMap(c){return new StringMap(c)}static fromArray(c){return StringMap.fromMap(new Map(c))}static of(...c){return of(StringMap,c)}static fromObject(c){return StringMap.fromArray(objToArr(c))}static metadata(c){return metadata$1(StringMap,reviverFactory$5,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_STRING_MAP||StringMap.of()}}StringMap.displayName="StringMap";var StringMap$1=Object.freeze(StringMap);const stringifyReducer$1=(c,e)=>{return c[e[0].toJSON()]=e[1],c},parseMapper$1=(c,e,h,j)=>l=>{const m=c("",l,j),o=e("",h[l],j.concat(l));return[m,o]},reviverFactory$6=(c,e)=>(h,j,l=[])=>{if(""!==h)return j;const m=reviverOrAsIs(c),o=reviverOrAsIs(e),p=null===j?null:new Map(Object.keys(j).map(parseMapper$1(m,o,j,l)));return new EnumMap(p)};let EMPTY_ENUM_MAP;class EnumMap extends AbstractMap$1{constructor(c){super(EnumMap,c,EMPTY_ENUM_MAP),EMPTY_ENUM_MAP||0!==this.size||(EMPTY_ENUM_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoEnumMap"}set(c,e){return set(this,EnumMap,c,e)}toJSON(){return[...this].reduce(stringifyReducer$1,{})}static fromMap(c){return new EnumMap(c)}static fromArray(c){return EnumMap.fromMap(new Map(c))}static of(...c){return of(EnumMap,c)}static metadata(c,e){return metadata$1(EnumMap,reviverFactory$6,c,e)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_ENUM_MAP||EnumMap.of()}}EnumMap.displayName="EnumMap";var EnumMap$1=Object.freeze(EnumMap);const reviver=(c,e)=>{return ModelicoNumber.of(e)};class ModelicoNumber extends Base$1{constructor(c=0){if(super(ModelicoNumber),!Number.isNaN(c)&&isNothing(c))throw TypeError("missing number");this.inner=always(+c),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoNumber"}set(){unsupported("Number.set is not supported")}setIn(c,e){return 0===c.length?ModelicoNumber.of(e):void unsupported("ModelicoNumber.setIn is not supported for non-empty paths")}toJSON(){const c=this.inner();return Object.is(c,-0)?"-0":c===Infinity?"Infinity":c===-Infinity?"-Infinity":Number.isNaN(c)?"NaN":c}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&haveSameValues(this.inner(),c.inner())}static of(c){return new ModelicoNumber(c)}static metadata(){return Object.freeze({type:ModelicoNumber,reviver})}static innerTypes(){return emptyObject}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(c,e)=>{const h=null===e?null:new Date(e);return new ModelicoDate(h)};class ModelicoDate extends Base$1{constructor(c=new Date){if(super(ModelicoDate),isNothing(c))throw TypeError("missing date");const e=new Date(c.getTime());this.inner=()=>new Date(e.getTime()),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoDate"}set(){unsupported("Date.set is not supported")}setIn(c,e){return 0===c.length?ModelicoDate.of(e):void unsupported("Date.setIn is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.toJSON()===c.toJSON()}static of(c){return new ModelicoDate(c)}static metadata(){return Object.freeze({type:ModelicoDate,reviver:reviver$1})}static innerTypes(){return emptyObject}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(c,e)=>(h,j,l=[])=>{if(""!==h)return j;const o=null===j?null:j.map((p,q)=>reviverOrAsIs(e)("",p,l.concat(q)));return new c(o)},iterableMetadata=(c,e)=>{return Object.freeze({type:c,subtypes:Object.freeze([e]),reviver:iterableReviverFactory(c,e)})},iterableEquals=(c,e,h=!1)=>{if(c===e)return!0;if(haveDifferentTypes(c,e)||c.size!==e.size)return!1;const j=c[Symbol.iterator](),l=e[Symbol.iterator]();for(let m=0;m<c.size;m+=1){const o=j.next().value;if(h){if(!e.has(o))return!1;}else if(!equals(o,l.next().value))return!1}return!0};let EMPTY_LIST;class List extends Base$1{constructor(c=[]){if(super(List),isNothing(c))throw TypeError("missing list");return EMPTY_LIST&&0===c.length?EMPTY_LIST:void(Object.freeze(c),this.inner=always(c),this[innerOrigSymbol]=this.inner,this.size=c.length,!EMPTY_LIST&&0===this.size&&(EMPTY_LIST=this),Object.freeze(this))}get[Symbol.toStringTag](){return"ModelicoList"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}includes(...c){return this.inner().includes(...c)}get(c){return this.inner()[c]}set(c,e){const h=[...this];return h[c]=e,List.fromArray(h)}setIn(c,e){if(0===c.length)return List.fromArray(e);const[h,...j]=c,l=this.inner()[h];return l.setIn?this.set(h,l.setIn(j,e)):this.set(h,e)}toJSON(){return this.inner()}equals(c){return iterableEquals(this,c)}static fromArray(c){return new List(c)}static of(...c){return List.fromArray(c)}static metadata(c){return iterableMetadata(List,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_LIST||List.of()}}List.displayName="List";var List$1=Object.freeze(List);let EMPTY_SET;const copy$1=c=>new Set(c);class ModelicoSet extends Base$1{constructor(c=new Set){if(super(ModelicoSet),isNothing(c))throw TypeError("missing set");if(EMPTY_SET&&0===c.size)return EMPTY_SET;const e=copy$1(c);this[innerOrigSymbol]=always(e),this.inner=()=>copy$1(e),this.size=e.size,EMPTY_SET||0!==this.size||(EMPTY_SET=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoSet"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}set(){unsupported("Set.set is not supported")}setIn(c,e){return 0===c.length?new ModelicoSet(e):void unsupported("Set.setIn is not supported for non-empty paths")}toJSON(){return[...this]}equals(...c){return iterableEquals(this,...c)}static fromSet(c){return new ModelicoSet(c)}static fromArray(c){return ModelicoSet.fromSet(new Set(c))}static of(...c){return ModelicoSet.fromArray(c)}static metadata(c){return iterableMetadata(ModelicoSet,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_SET||ModelicoSet.of()}}ModelicoSet.displayName="ModelicoSet";var ModelicoSet$1=Object.freeze(ModelicoSet);const proxyToSelf=(c,e,h,j,l)=>{return c.includes(l)?(...m)=>{const o=j[l](...m);return proxyFactory(c,e,h,o)}:j[l]},proxyToInner=(c,e,h,j,l,m,o)=>{return h.includes(o)?(...p)=>{const q=m.setIn([],e.apply(c,p));return proxyFactory(h,j,l,q)}:j.includes(o)?(...p)=>{e.apply(c,p);const q=m.setIn([],c);return proxyFactory(h,j,l,q)}:(...p)=>{return e.apply(c,p)}},proxyFactory=(c,e,h,j)=>{return new Proxy(j,{get:(m,o)=>{if(o in m)return proxyToSelf(c,e,h,m,o);const p=h(m.inner()),q=p[o];return"function"==typeof q?proxyToInner(p,q,c,e,h,m,o):q}})},formatError=(c,e,h,j=[])=>["Invalid JSON at \""+j.join(" > ")+"\". According to the schema\n",JSON.stringify(e,null,2)+"\n","the value\n",JSON.stringify(h,null,2)+"\n",c.errors[0].message].join("\n"),formatDefaultValueError=(c,e,h)=>["Invalid default value. According to the schema\n",JSON.stringify(e,null,2)+"\n","the default value\n",JSON.stringify(h,null,2)+"\n",c.errors[0].message].join("\n");var ajvMetadata=(c={validate:T})=>{const{_:e,asIs:h,any:j,string:l,number:m,boolean:o,date:p,enumMap:q,list:r,map:s,stringMap:t,set:u,maybe:w,withDefault:y}=M.metadata(),z=(R,S,U=identity)=>(V,W,X)=>{if(""!==V)return W;const Y=c.validate(S,U(W));if(!Y)throw TypeError(formatError(c,S,W,X));return R.reviver("",W,X)},A=(R,S,U)=>(V,W)=>{if(""!==V)return W;const X=z(R,S)(V,W);return z(j(),U,Y=>Y.inner())(V,X)},B=(R,S,U={},V={})=>{const W=Object.assign({},S,U),X=z(R,W),Y=Object.assign({},W,V);return Object.assign({},R,{reviver:X,schema:Y})},D=(R,S=identity)=>B(h(S),R);return Object.freeze({ajv_:(R,S={},U,V)=>{const W=e(R,U,V);return B(W,{},S,getSchema(W))},ajvAsIs:D,ajvAny:R=>D(R),ajvNumber:(R,S={})=>{const{wrap:U=!1}=S,V=m(S);if(!U)return B(V,{type:"number"},R);const W=Object.assign({type:"number"},R),X=A(V,{anyOf:[{type:"number"},{type:"string",enum:["-0","-Infinity","Infinity","NaN"]}]},W);return Object.assign({},V,{reviver:X,schema:W})},ajvString:R=>B(l(),{type:"string"},R),ajvBoolean:R=>B(o(),{type:"boolean"},R),ajvDate:R=>B(p(),{type:"string",format:"date-time"},R),ajvEnumMap:(R,S,U)=>B(q(S,U),{type:"object",maxProperties:Object.keys(S).length},R,{properties:getSchema(U)}),ajvList:(R,S)=>B(r(S),{type:"array"},R,{items:getSchema(S)}),ajvMap:(R,S,U)=>{const V={type:"array",items:{type:"array",minItems:2,maxItems:2}},W={items:Object.assign({items:[getSchema(S),getSchema(U)]},V.items)};return B(s(S,U),V,R,W)},ajvStringMap:(R,S)=>B(t(S),{type:"object"},R,{properties:getSchema(S)}),ajvSet:(R,S)=>B(u(S),{type:"array",uniqueItems:!0},R,{items:getSchema(S)}),ajvMaybe:R=>B(w(R),{},{},getSchema(R)),ajvWithDefault:(R,S)=>{const U=getSchema(R),V=c.validate(U,S);if(!V)throw TypeError(formatDefaultValueError(c,U,S));return B(y(R,S),{},{},U)}})},asIs=(c=identity)=>Object.freeze({type:c,reviver:asIsReviver(c)});const internalNonMutators=["set","setIn"],mapNonMutators=internalNonMutators,mapMutators=["delete","clear"],setNonMutators=internalNonMutators,setMutators=["add","delete","clear"],listNonMutators=internalNonMutators.concat(["concat","slice","filter"]),listMutators=["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],_=function(c,e=[],h=[]){return c.metadata?c.metadata(...h):Object.freeze({type:c,reviver:reviverFactory(e,c)})},metadata=()=>Object.freeze({_,asIs,any:always(asIs(identity)),number:({wrap:c=!1}={})=>c?ModelicoNumber$1.metadata():asIs(Number),string:always(asIs(String)),boolean:always(asIs(Boolean)),date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$1.metadata,map:ModelicoMap$1.metadata,stringMap:StringMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata,withDefault:(c,e)=>{const h=reviverOrAsIs(c)("",e);return Object.freeze(Object.assign({},c,{default:h}))}}),proxyMap=partial(proxyFactory,mapNonMutators,mapMutators,identity),fromJS=(c,e)=>_(c).reviver("",e),genericsFromJS=(c,e,h)=>_(c,[],e).reviver("",h),ajvFromJS=(c,e,h,j)=>c(e,h).reviver("",j),ajvGenericsFromJS=(c,e,h,j,l)=>c(e,h,[],j).reviver("",l),createModel=(c,e="ModelicoModel",h)=>{return class extends Base$1{get[Symbol.toStringTag](){return e}static of(j){return fromJS(h(),j)}static innerTypes(j,l){return"function"==typeof c?c(j,l):Object.freeze(c)}}};var M={about:Object.freeze({version,author,homepage,license}),Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum,EnumMap:EnumMap$1,List:List$1,Map:ModelicoMap$1,StringMap:StringMap$1,Maybe:Maybe$1,Base:Base$1,Set:ModelicoSet$1,createModel,fields:c=>c[fieldsSymbol](),symbols,fromJS,genericsFromJS,fromJSON:(c,e)=>fromJS(c,JSON.parse(e)),genericsFromJSON:(c,e,h)=>genericsFromJS(c,e,JSON.parse(h)),ajvFromJS,ajvGenericsFromJS,ajvFromJSON:(c,e,h,j)=>ajvFromJS(c,e,h,JSON.parse(j)),ajvGenericsFromJSON:(c,e,h,j,l)=>ajvGenericsFromJS(c,e,h,j,JSON.parse(l)),metadata,ajvMetadata,getSchema,withValidation,proxyMap,proxyEnumMap:proxyMap,proxyStringMap:proxyMap,proxyList:partial(proxyFactory,listNonMutators,listMutators,c=>[...c]),proxySet:partial(proxyFactory,setNonMutators,setMutators,identity),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators,identity)};export default M;

