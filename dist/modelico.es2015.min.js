var _NumberisNaN=Number.isNaN;import{List,Map as Map$1,OrderedMap,OrderedSet,Set as Set$1}from"immutable";var version="23.0.0",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico/tree/immutable-js#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),innerOrigSymbol=Symbol("innerOrig");var symbols=Object.freeze({typeSymbol:typeSymbol,fieldsSymbol:fieldsSymbol,innerOrigSymbol:innerOrigSymbol});const get=(c)=>(h)=>h[c],pipe2=(c,h)=>(...j)=>h(c(...j)),not=(c)=>!c,T=()=>!0,identity=(c)=>c,pipe=(...c)=>[...c,identity].reduce(pipe2),partial=(c,...h)=>c.bind(void 0,...h),asIsReviver=(c)=>(h,j)=>c(j),always=(c)=>()=>c,isNothing=(c)=>null==c||_NumberisNaN(c),isSomething=pipe2(isNothing,not),assertSomethingIdentity=(c)=>{if(isNothing(c))throw TypeError(`expected a value but got nothing (null, undefined or NaN)`);return c},defaultTo=(c)=>(h)=>isNothing(h)?c:h,objToArr=(c)=>Object.keys(c).map((h)=>[h,c[h]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(assertSomethingIdentity))),isPlainObject=(c)=>"object"==typeof c&&!!c,isFunction=(c)=>"function"==typeof c,emptyObject=Object.freeze({}),emptyArray=Object.freeze([]),haveSameValues=(c,h)=>c===h||Object.is(c,h),haveSameType=(c,h)=>null==c||null==h?c===h:c.constructor===h.constructor,haveDifferentTypes=pipe2(haveSameType,not),equals=(c,h)=>isSomething(c)&&c.equals?c.equals(h):haveSameValues(c,h),unsupported=(c)=>{throw Error(c)},metaOrTypeMapper=(c)=>(h)=>isPlainObject(h)?h:c(h),formatAjvError=(c,h,j,l=[])=>["Invalid JSON at \""+l.join(" -> ")+"\". According to the schema\n",JSON.stringify(h,null,2)+"\n","the value (data path \""+c.errors.filter((o)=>""!==o.dataPath).map((o)=>o.dataPath)+"\")\n",JSON.stringify(j,null,2)+" "+Object.prototype.toString.call(j)+"\n"].concat(c.errors.map((o)=>o.message)).join("\n"),memCacheRegistry=new WeakMap,memDefaultCacheFn=()=>new WeakMap,mem=(c,h=memDefaultCacheFn)=>(j,...l)=>{if(0<l.length)return c(j,...l);memCacheRegistry.has(c)||memCacheRegistry.set(c,h());const o=memCacheRegistry.get(c)||h(),p=void 0===j?emptyObject:j;return o.has(p)||o.set(p,c(j,...l)),o.get(p)},innerTypesCache=new WeakMap,getInnerTypes=(c,h)=>{return h.innerTypes(c,h)};var getInnerTypes$1=(c,h)=>{return innerTypesCache.has(h)||innerTypesCache.set(h,getInnerTypes(c,h)),innerTypesCache.get(h)||emptyObject};const metadataSchemaCache=new WeakMap;let state;const defaultState=()=>({nextRef:1,definitions:{},usedDefinitions:new Set,metadataRefCache:new WeakMap}),enhanceSchemaWithDefault=(c,h)=>{if(c.default===void 0)return h;const j={default:c.default};return h===emptyObject?Object.assign({},{type:emptyObject},j):Object.assign({},{anyOf:[{type:"null"},h]},c.type===M.Maybe?void 0:j)},getSchemaImpl=(c)=>{if(c.schema)return enhanceSchemaWithDefault(c,c.schema());const h=c.type&&c.type.innerTypes;if(!h)return enhanceSchemaWithDefault(c,emptyObject);const j=getInnerTypes$1([],c.type);if(0===Object.keys(j).length)return emptyObject;const o=[],p=Object.keys(j).reduce((r,s)=>{const t=j[s],u=getSchema(t,!1);return void 0===t.default&&o.push(s),Object.assign(r,{[s]:u})},{}),q=Object.assign({},{type:"object"},{properties:p});return 0<o.length&&(q.required=o),enhanceSchemaWithDefault(c,q)},getUsedDefinitions=()=>{const{definitions:c,usedDefinitions:h}=state;return Object.keys(c).map(Number).reduce((j,l)=>{return h.has(l)&&(j[l]=c[l]),j},{})},getSchema=(c,h=!0)=>{if(metadataSchemaCache.has(c))return metadataSchemaCache.get(c)||emptyObject;if(h&&(state=defaultState()),state.metadataRefCache.has(c)){const q=state.metadataRefCache.get(c)||state.nextRef;return state.usedDefinitions.add(q),{$ref:`#/definitions/${q}`}}const j=state.nextRef;state.metadataRefCache.set(c,j),state.nextRef+=1;const l=getSchemaImpl(c);if(Object.assign(state.definitions,{[j]:l}),!h){const q=state.metadataRefCache.get(c),r=Object.keys(l);return q&&(!(1>=r.length)||Array.isArray(l[r[0]]))?(state.usedDefinitions.add(q),{$ref:`#/definitions/${q}`}):l}const o=getUsedDefinitions();let p;return p=0===Object.keys(o).length?l:o.hasOwnProperty(j)?{definitions:Object.assign(o,{[j]:l}),$ref:`#/definitions/${j}`}:Object.assign({},l,{definitions:o}),metadataSchemaCache.set(c,p),p};var validate=(c,h=[])=>{if(!(c instanceof M.Base))throw TypeError("Modelico.validate only works with instances of Modelico.Base");try{M.genericsFromJSON(c[M.symbols.typeSymbol](),h,JSON.stringify(c))}catch(j){return[!1,j]}return[!0,void 0]};const defaultErrorMsgFn=(c,h)=>`Invalid value at "${h.join(" -> ")}"`;var withValidation=(c,h=defaultErrorMsgFn)=>(j)=>{return Object.assign({},j,{reviver:(o,p,q=[])=>{if(""!==o)return p;const r=j.reviver("",p,q);if(!c(r))throw TypeError(h(r,q));return r}})};const cacheRegistry=new WeakMap,withCache=(c,h,j=[],l=h)=>{cacheRegistry.has(c)||cacheRegistry.set(c,new Map);const o=cacheRegistry.get(c);return o.has(l)||o.set(l,h.apply(c,j)),o.get(l)};var asIs=mem((c=identity)=>Object.freeze({type:c,reviver:asIsReviver(pipe(assertSomethingIdentity,c)),maybeReviver:asIsReviver(c)})),any=always(asIs(identity)),anyOf=(c=[],h="type")=>(j,l)=>{if(0===c.length)return any;const o=c[0][1][typeSymbol](),p=o.metadata().reviver("",j[h]);for(let r=0;r<c.length;r+=1){const s=c[r],t=s[0],u=s[1];if(p===u)return t}const q=l.slice(0,-1);throw TypeError(`unsupported enumerator "${p.toJSON()}" at "${q.join(" -> ")}"`)};const plainObjectReviverFactory=(c,h,j,l)=>Object.keys(j).reduce((o,p)=>{const q=l.concat(p),r=getInnerTypes$1(l,c),s=r[p],t=isFunction(s)?s(j,q):s;return o[p]=t?reviverOrAsIs(t)(h,j[p],q):j[p],o},{}),reviverFactory=(c)=>(h,j,l=[])=>{if(""!==h)return j;const o=isPlainObject(j)?plainObjectReviverFactory(c,h,j,l):j;return new c(o)},isMatch=(c)=>(h)=>{const j=h.type.innerTypes(),l=Object.keys(j),o=isPlainObject(c);return 0===l.length&&o?!1:l.filter((p)=>!j[p].hasOwnProperty("default")).every((p)=>!!o&&c.hasOwnProperty(p))},inferClassifier=(c)=>(h)=>{const j=c.filter(isMatch(h),[]);if(0===j.length)throw Error("Unable to infer type");if(1<j.length)throw Error("Ambiguous object: more than one metadata matches the object. A custom classifier can be passed as a second argument.");return j[0]},getPathReducer=(c,h)=>c.get(h);class Base{constructor(c,h=emptyObject,j){if(!isPlainObject(h))throw TypeError(`expected an object with fields for ${c.displayName||c.name} but got ${h}`);Object.freeze(h);const l={},o=getInnerTypes$1([],c);j=defaultTo(this)(j),j[typeSymbol]=always(c),Object.keys(o).forEach((p)=>{const q=h[p],r=o[p].default;let s;if(isSomething(q))s=q;else if(r!==void 0)s=o[p].reviver("",r),l[p]=s;else throw TypeError(`no value for key "${p}"`);j[p]=always(s)}),j[fieldsSymbol]=always(Object.freeze(Object.assign(l,h)))}get[Symbol.toStringTag](){return"ModelicoModel"}get(c){return this[fieldsSymbol]()[c]}getIn(c){return c.reduce(getPathReducer,this)}copy(c){const h=Object.assign({},this[fieldsSymbol](),c);return new(this[typeSymbol]())(h)}set(c,h){return this.copy({[c]:h})}setIn(c,h){if(0===c.length)return this.copy(h);const[j,...l]=c,o=this[j]();return o.setIn?this.set(j,o.setIn(l,h)):this.set(j,h)}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const h=this[fieldsSymbol](),j=c[fieldsSymbol](),l=Object.keys(h),o=Object.keys(j);return!(l.length!==o.length)&&l.every((p)=>equals(h[p],j[p]))}toJSON(){return this[fieldsSymbol]()}toJS(){return JSON.parse(JSON.stringify(this))}stringify(c){return JSON.stringify(this,null,c)}static innerTypes(){return emptyObject}static factory(...c){return new Base(...c)}}var Base$1=Object.freeze(Base);const set=(c,h,j,l)=>{const o=c.inner(),p=o.set(j,l);return o===p?c:h.fromArray([...p])},of=(c,h)=>{const j=h.length;if(1==j%2)throw TypeError(`${c.displayName}.of requires an even number of arguments`);const l=new Map;for(let o=0;o<j;o+=2)l.set(h[o],h[o+1]);return c.fromMap(l)},metadata$2=mem((c)=>mem((h)=>mem((j)=>mem((l)=>{return Object.freeze({type:c,subtypes:Object.freeze([j,l]),reviver:h(j,l)})}))));class AbstractMap extends Base$1{constructor(c,h=new Map,j){if(super(c),isNothing(h))throw TypeError("missing map");if(j&&0===h.size)return j;const l=OrderedMap(h);this[innerOrigSymbol]=always(l),this.inner=always(l),this.size=l.size}[Symbol.iterator](){return this[innerOrigSymbol]()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}get(c){return this[innerOrigSymbol]().get(c)}setIn(c,h){if(0===c.length)return new(this[typeSymbol]())(h);const[j,...l]=c,o=this[innerOrigSymbol]().get(j);return o.setIn?this.set(j,o.setIn(l,h)):this.set(j,h)}equals(c,h=!1){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const j=h?Map$1:identity;return j(this.inner()).equals(j(c.inner()))}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(c,h,j)=>(l,o)=>[c("",l[0],j.concat(o,0)),h("",l[1],j.concat(o,1))],reviverFactory$2=(c,h)=>(j,l,o=[])=>{if(""!==j)return l;const p=reviverOrAsIs(isFunction(c)?c(l,o):c),q=reviverOrAsIs(isFunction(h)?h(l,o):h),r=null===l?null:new Map(l.map(parseMapper(p,q,o)));return ModelicoMap.fromMap(r)};let EMPTY_MAP;class ModelicoMap extends AbstractMap$1{constructor(c){super(ModelicoMap,c,EMPTY_MAP),EMPTY_MAP||0!==this.size||(EMPTY_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMap"}set(c,h){return set(this,ModelicoMap,c,h)}toJSON(){return[...this]}static fromMap(c){return new ModelicoMap(c)}static fromArray(c){return ModelicoMap.fromMap(new Map(c))}static of(...c){return of(ModelicoMap,c)}static fromObject(c){return ModelicoMap.fromArray(objToArr(c))}static metadata(c,h){return metadata$2(ModelicoMap)(reviverFactory$2)(c)(h)}static EMPTY(){return EMPTY_MAP||ModelicoMap.of()}}ModelicoMap.displayName="ModelicoMap";var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(c,h)=>{return c[h[0]]=h[1],c},parseReducer=(c,h,j)=>(l,o)=>[...l,[o,c("",h[o],j.concat(o))]],reviverFactory$3=(c)=>(h,j,l=[])=>{if(""!==h)return j;const o=reviverOrAsIs(isFunction(c)?c(j,l):c),p=null===j?null:new Map(Object.keys(j).reduce(parseReducer(o,j,l),[]));return StringMap.fromMap(p)};let EMPTY_STRING_MAP;class StringMap extends AbstractMap$1{constructor(c){super(StringMap,c,EMPTY_STRING_MAP),EMPTY_STRING_MAP||0!==this.size||(EMPTY_STRING_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoStringMap"}set(c,h){return set(this,StringMap,c,h)}toJSON(){return[...this].reduce(stringifyReducer,{})}static fromMap(c){return new StringMap(c)}static fromArray(c){return StringMap.fromMap(new Map(c))}static of(...c){return of(StringMap,c)}static fromObject(c){return StringMap.fromArray(objToArr(c))}static metadata(c){return metadata$2(StringMap)(reviverFactory$3)(c)()}static EMPTY(){return EMPTY_STRING_MAP||StringMap.of()}}StringMap.displayName="StringMap";var StringMap$1=Object.freeze(StringMap);const stringifyReducer$1=(c,h)=>{return c[h[0].toJSON()]=h[1],c},parseMapper$1=(c,h,j,l)=>(o)=>{const p=c("",o,l),q=h("",j[o],l.concat(o));return[p,q]},reviverFactory$4=(c,h)=>(j,l,o=[])=>{if(""!==j)return l;const p=reviverOrAsIs(isFunction(c)?c(l,o):c),q=reviverOrAsIs(isFunction(h)?h(l,o):h),r=null===l?null:new Map(Object.keys(l).map(parseMapper$1(p,q,l,o)));return new EnumMap(r)};let EMPTY_ENUM_MAP;class EnumMap extends AbstractMap$1{constructor(c){super(EnumMap,c,EMPTY_ENUM_MAP),EMPTY_ENUM_MAP||0!==this.size||(EMPTY_ENUM_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoEnumMap"}set(c,h){return set(this,EnumMap,c,h)}toJSON(){return[...this].reduce(stringifyReducer$1,{})}static fromMap(c){return new EnumMap(c)}static fromArray(c){return EnumMap.fromMap(new Map(c))}static of(...c){return of(EnumMap,c)}static metadata(c,h){return metadata$2(EnumMap)(reviverFactory$4)(c)(h)}static EMPTY(){return EMPTY_ENUM_MAP||EnumMap.of()}}EnumMap.displayName="EnumMap";var EnumMap$1=Object.freeze(EnumMap);const reviver=(c,h)=>{return ModelicoNumber.of(h)},metadata$3=mem(()=>Object.freeze({type:ModelicoNumber,reviver}));class ModelicoNumber extends Base$1{constructor(c=0){if(super(ModelicoNumber),!_NumberisNaN(c)&&isNothing(c))throw TypeError("missing number");this.inner=always(+c),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoNumber"}set(){unsupported("Number.set is not supported")}setIn(c,h){return 0===c.length?ModelicoNumber.of(h):void unsupported("ModelicoNumber.setIn is not supported for non-empty paths")}toJSON(){const c=this.inner();return Object.is(c,-0)?"-0":c===Infinity?"Infinity":c===-Infinity?"-Infinity":_NumberisNaN(c)?"NaN":c}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&haveSameValues(this.inner(),c.inner())}static of(c){return new ModelicoNumber(c)}static metadata(){return metadata$3()}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(c,h)=>{const j=null===h?null:new Date(h);return new ModelicoDate(j)},metadata$4=mem(()=>Object.freeze({type:ModelicoDate,reviver:reviver$1}));class ModelicoDate extends Base$1{constructor(c=new Date){if(super(ModelicoDate),isNothing(c))throw TypeError("missing date");const h=new Date(c.getTime());this.inner=()=>new Date(h.getTime()),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoDate"}set(){unsupported("Date.set is not supported")}setIn(c,h){return 0===c.length?ModelicoDate.of(h):void unsupported("Date.setIn is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.toJSON()===c.toJSON()}static of(c){return new ModelicoDate(c)}static metadata(){return metadata$4()}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(c,h)=>(j,l,o=[])=>{if(""!==j)return l;const p=Array.isArray(h);if(p&&l.length!==h.length)throw TypeError("tuple has missing or extra items");const q=p?(t)=>isFunction(h[t])?h[t](l,o):h[t]:isFunction(h)?always(h(l,o)):always(h),s=null===l?null:l.map((t,u)=>reviverOrAsIs(q(u))("",t,o.concat(u)));return new c(s)},iterableMetadata=mem((c)=>mem((h)=>{return Object.freeze({type:c,subtypes:Object.freeze([h]),reviver:iterableReviverFactory(c,h)})})),iterableEquals=(c,h,j=!1)=>{if(c===h)return!0;if(haveDifferentTypes(c,h))return!1;const l=j?Set$1:identity;return l(c.inner()).equals(l(h.inner()))};let EMPTY_LIST;class List$1 extends Base$1{constructor(c=[]){if(super(List$1),isNothing(c))throw TypeError("missing list");if(EMPTY_LIST&&0===c.length)return EMPTY_LIST;Object.freeze(c);const h=List(c);this.inner=always(h),this[innerOrigSymbol]=this.inner,this.size=h.size,EMPTY_LIST||0!==this.size||(EMPTY_LIST=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoList"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}includes(...c){return this.inner().includes(...c)}get(c){return this.inner().get(c)}set(c,h){const j=[...this.inner().set(c,h)];return List$1.fromArray(j)}setIn(c,h){if(0===c.length)return List$1.fromArray(h);const[j,...l]=c,o=this.inner().get(j);return o.setIn?this.set(j,o.setIn(l,h)):this.set(j,h)}toJSON(){return[...this.inner()]}toArray(){return this.toJSON()}equals(c){return iterableEquals(this,c)}static fromArray(c){return new List$1(c)}static of(...c){return List$1.fromArray(c)}static metadata(c){return iterableMetadata(List$1)(c)}static EMPTY(){return EMPTY_LIST||List$1.of()}}List$1.displayName="List";var List$2=Object.freeze(List$1);let EMPTY_SET;class ModelicoSet extends Base$1{constructor(c=new Set){if(super(ModelicoSet),isNothing(c))throw TypeError("missing set");if(EMPTY_SET&&0===c.size)return EMPTY_SET;const h=OrderedSet(c);this[innerOrigSymbol]=always(h),this.inner=always(h),this.size=h.size,EMPTY_SET||0!==this.size||(EMPTY_SET=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoSet"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}set(){unsupported("Set.set is not supported")}setIn(c,h){return 0===c.length?new ModelicoSet(h):void unsupported("Set.setIn is not supported for non-empty paths")}toJSON(){return[...this]}equals(...c){return iterableEquals(this,...c)}static fromSet(c){return new ModelicoSet(c)}static fromArray(c){return ModelicoSet.fromSet(new Set(c))}static of(...c){return ModelicoSet.fromArray(c)}static metadata(c){return iterableMetadata(ModelicoSet)(c)}static EMPTY(){return EMPTY_SET||ModelicoSet.of()}}ModelicoSet.displayName="ModelicoSet";var ModelicoSet$1=Object.freeze(ModelicoSet);const reviverFactory$5=(c)=>(h,j,l)=>{if(""!==h)return j;if(null===j)return new Nothing;const o=isFunction(c)?c(j,l):c,p=defaultTo(o.reviver)(o.maybeReviver),q=p(h,j,l);return Maybe.of(q)},metadata$5=mem((c)=>Object.freeze({type:Maybe,subtypes:[c],reviver:reviverFactory$5(c),default:null}));class Maybe extends Base$1{get(c){const h=c[0],j=c[1],l=this.getOrElse(h);return l.get?l.get(j):l}set(c,h){if(this.isEmpty())return this;const j=this.inner();if(isNothing(j))return this;const l=j.set?j.set(c,h):null;return Maybe.of(l)}setIn(c,h){if(0===c.length)return Maybe.of(h);const[j,...l]=c,o=j[0],p=j[1],q=this.isEmpty()?o:this.inner(),r=q.setIn?q.setIn([p,...l],h):null;return Maybe.of(r)}static of(c){return isNothing(c)||c instanceof Nothing?new Nothing:new Just(c)}static metadata(c){return metadata$5(c)}}Maybe.displayName="Maybe";let nothing;class Nothing extends Maybe{constructor(){return super(Nothing),nothing||(this.inner=()=>{throw TypeError("nothing holds no value")},nothing=this),nothing}get[Symbol.toStringTag](){return"ModelicoNothing"}toJSON(){return null}isEmpty(){return!0}getOrElse(c){return c}map(){return this}flatMap(){return this}equals(c){return this===c}}Nothing.displayName="Nothing";class Just extends Maybe{constructor(c){super(Just),this.inner=always(c),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoJust"}toJSON(){const c=this.inner();return isNothing(c)?null:c.toJSON?c.toJSON():c}isEmpty(){return!1}getOrElse(){return this.inner()}map(c){return Just.of(c(this.inner()))}flatMap(c){const h=c(this.inner());if(!(h instanceof Maybe))throw TypeError("Maybe.flatMap expects a Maybe-returning function");return h}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&equals(this.inner(),c.inner())}static of(c){return new Just(c)}}Just.displayName="Just",Maybe.Nothing=new Nothing,Maybe.Just=Just;var Maybe$1=Object.freeze(Maybe);const base=mem((c)=>Object.freeze({type:c,reviver:reviverFactory(c)})),_impl=(c,h)=>c.metadata?c.metadata(...h):base(c),_implMem=mem((c)=>mem((h)=>_impl(c,h))),_$1=(c,h=emptyArray)=>_implMem(c)(h),withDefaultImpl=(c,h)=>{return Object.freeze(Object.assign({},c,{default:JSON.parse(JSON.stringify(h)),reviver:(l,o,p=[])=>{if(""!==l)return o;if(isNothing(o)){const q=defaultTo(c)(c.baseMetadata);return q.reviver(l,h,p)}return c.reviver(l,o,p)}}))},withDefaultMem=mem((c)=>mem((h)=>withDefaultImpl(c,h),()=>new Map)),withDefault=(c,h)=>withDefaultMem(c)(h),union=(c,h,j)=>{const l=h.map(metaOrTypeMapper(_$1));j=j===void 0?inferClassifier(l):j;return Object.assign({},base(c),{reviver:(p,q,r=[])=>{return""===p?j(q,l).reviver(p,q,r):q},subtypes:l})},metadata$1=always(Object.freeze({_:_$1,base,asIs,any,anyOf,union,number:always(asIs(Number)),string:always(asIs(String)),boolean:always(asIs(Boolean)),wrappedNumber:ModelicoNumber$1.metadata,date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$2.metadata,map:ModelicoMap$1.metadata,stringMap:StringMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata,withDefault})),getInnerSchema=(c)=>M.getSchema(c,!1);var ajvMetadata=mem((c={validate:T})=>{const h=M.getSchema,j=M.metadata(),l={},{_:o,base:p,asIs:q,any:r,anyOf:s,union:t,string:u,number:w,wrappedNumber:y,boolean:z,date:A,enumMap:B,list:C,map:D,stringMap:E,set:F,maybe:G,withDefault:H}=j,I=(ia,ja,ka=identity,la="reviver")=>(ma,na,oa=[])=>{if(""!==ma)return na;const pa=ja===emptyObject||c.validate(ja,ka(na));if(!pa)throw TypeError(formatAjvError(c,ja,na,oa));const qa=isFunction(ia)?ia(na,oa):ia;return qa[la]("",na,oa)},J=(ia,ja,ka,la)=>(ma,na,oa=[])=>{if(""!==ma)return na;const pa=I(ia,ja,identity,la)(ma,na);return I(r(),ka,(qa)=>qa.inner(),la)(ma,pa,oa)},K=(ia,ja,ka=emptyObject,la=always(emptyObject))=>{const ma=ja===emptyObject&&ka===emptyObject?emptyObject:Object.assign({},ja,ka),na=I(ia,ma),pa=isFunction(ia)?{type:ia}:ia,qa=Object.assign({},pa,{baseMetadata:pa,reviver:na,ownSchema:always(ma),schema:()=>Object.assign({},ma,la())});return ia.maybeReviver&&(qa.maybeReviver=I(ia,ma,identity,"maybeReviver")),qa};l.ajvMeta=K;const L=(ia,ja,ka,la)=>{const ma=o(ia,ja);return ka===emptyObject?ma:K(ma,emptyObject,ka,()=>h(ma,la))},N=mem((ia)=>mem((ja)=>mem((ka)=>mem((la)=>L(ia,ja,ka,la),()=>new Map))));l._=(ia,ja,ka=emptyObject,la=!1)=>N(ia)(ja)(ka)(la);const O=(ia,ja,ka)=>{const la=p(ia);return ja===emptyObject?la:K(la,{type:"object"},ja,()=>h(la,ka))},P=mem((ia)=>mem((ja)=>mem((ka)=>O(ia,ja,ka),()=>new Map)));l.base=(ia,ja=emptyObject,ka=!1)=>P(ia)(ja)(ka);const Q=(ia,ja)=>K(q(ia),ja),R=mem((ia)=>mem((ja)=>Q(ia,ja)));l.asIs=(ia,ja)=>R(ia)(ja),l.any=(ia)=>l.asIs(identity,ia),l.wrappedNumber=mem((ia)=>{const ja=y(),ka=Object.assign({type:"number"},ia),ma=J(ja,{anyOf:[{type:"number"},{enum:["-0","-Infinity","Infinity","NaN"]}]},ka);return Object.assign({},ja,{reviver:ma,ownSchema:always(ka),schema:always(ka)})}),l.number=mem((ia)=>K(w(),{type:"number"},ia)),l.string=mem((ia)=>K(u(),{type:"string"},ia)),l.boolean=mem((ia)=>K(z(),{type:"boolean"},ia)),l.date=mem((ia)=>K(A(),{type:"string",format:"date-time"},ia)),l._enum=mem((ia)=>{const ja=o(ia);return K(ja,{enum:Object.keys(ja.enumerators)})});const S=(ia,ja,ka)=>{const la=Object.keys(ia.enumerators),ma=`^(${la.join("|")})$`;return K(B(ia,ja),{type:"object",maxProperties:la.length,additionalProperties:!1,patternProperties:{[ma]:{}}},ka,()=>({patternProperties:{[ma]:getInnerSchema(ja,!1)}}))},U=mem((ia)=>mem((ja)=>mem((ka)=>S(ia,ja,ka))));l.enumMap=(ia,ja,ka)=>U(ia)(ja)(ka);const V=(ia,ja)=>K(C(ia),{type:"array"},ja,()=>({items:getInnerSchema(ia)})),W=mem((ia)=>mem((ja)=>V(ia,ja))),X=(ia,ja)=>{const ka=ia.length;return K(C(ia),{type:"array",minItems:ka,maxItems:ka},ja,()=>({items:ia.map((la)=>getInnerSchema(la))}))},Y=mem((ia)=>mem((ja)=>X(ia,ja)));l.list=(ia,ja)=>Array.isArray(ia)?Y(ia)(ja):W(ia)(ja);const Z=(ia,ja,ka)=>{const la={type:"array",items:{type:"array",minItems:2,maxItems:2}};return K(D(ia,ja),la,ka,()=>({items:Object.assign({items:[getInnerSchema(ia),getInnerSchema(ja)]},la.items)}))},$=mem((ia)=>mem((ja)=>mem((ka)=>Z(ia,ja,ka))));l.map=(ia,ja,ka)=>$(ia)(ja)(ka);const aa=(ia,ja)=>K(E(ia),{type:"object"},ja,()=>({additionalProperties:!1,patternProperties:{".*":getInnerSchema(ia)}})),ba=mem((ia)=>mem((ja)=>aa(ia,ja)));l.stringMap=(ia,ja)=>ba(ia)(ja);const ca=(ia,ja)=>K(F(ia),{type:"array",uniqueItems:!0},ja,()=>({items:getInnerSchema(ia)})),da=mem((ia)=>mem((ja)=>ca(ia,ja)));l.set=(ia,ja)=>da(ia)(ja);const ea=(ia,ja)=>K(G(ia),emptyObject,ja,()=>getInnerSchema(ia)),fa=mem((ia)=>mem((ja)=>ea(ia,ja)));l.maybe=(ia,ja)=>fa(ia)(ja);const ga=(ia,ja,ka)=>K(H(ia,ja),emptyObject,ka,()=>getInnerSchema(ia)),ha=mem((ia)=>mem((ja)=>mem((ka)=>ga(ia,ja,ka)),()=>new Map));return l.withDefault=(ia,ja,ka)=>ha(ia)(ja)(ka),l.anyOf=(ia,ja)=>K(s(ia,ja),{anyOf:ia.map((ka)=>getInnerSchema(ka[0]))}),l.union=(ia,ja,ka)=>{const la=ja.map(metaOrTypeMapper(o)),ma=t(ia,la,ka);return K(ma,emptyObject,emptyObject,()=>({anyOf:la.map(getInnerSchema)}))},Object.freeze(Object.assign({},j,l))});const enumeratorsReducer=(c,h)=>Object.assign(c,{[h]:{code:h}}),reviverFactory$6=(c)=>(h,j,l=[])=>{const o=c[j];if(isNothing(o))throw TypeError(`missing enumerator "${j}" at "${l.join(" -> ")}"`);return o};class Enum extends Base$1{constructor(c,h=Enum,j=h.displayName){const l=Array.isArray(c)?c.reduce(enumeratorsReducer,{}):c;h!==Enum&&(h.displayName=j,Object.freeze(h)),super(h),Object.getOwnPropertyNames(l).forEach((o)=>{this[o]=always(l[o]),l[o][typeSymbol]=always(this),l[o].toJSON=always(o),l[o].equals=(p)=>l[o]===p}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:this,enumerators:l,reviver:reviverFactory$6(l)}))})}static fromObject(...c){return new Enum(...c)}static fromArray(...c){return new Enum(...c)}}Object.defineProperty(Enum,"displayName",{value:"Enum",writable:!0});const proxyToSelf=(c,h,j,l,o)=>{return c.includes(o)?(...p)=>{const q=l[o](...p);return proxyFactory(c,h,j,q)}:l[o]},proxyToInner=(c,h,j,l,o,p,q)=>{return j.includes(q)?(...r)=>{const s=p.setIn([],h.apply(c,r));return proxyFactory(j,l,o,s)}:l.includes(q)?(...r)=>{h.apply(c,r);const s=p.setIn([],c);return proxyFactory(j,l,o,s)}:(...r)=>{return h.apply(c,r)}},proxyFactory=(c,h,j,l)=>{return new Proxy(l,{get:(p,q)=>{if(q in p)return proxyToSelf(c,h,j,p,q);const r=j(p.inner()),s=r[q];return"function"==typeof s?proxyToInner(r,s,c,h,j,p,q):s}})},metadata$6=metadata$1(),createModel=(c=emptyObject,{base:h=Base$1,stringTag:j="ModelicoModel",metadata:l=metadata$6}={})=>{const o=class extends h{constructor(){const p=arguments;if(2===p.length)super(p[0],p[1]);else{const q=p[0],r=void 0===q?{}:q;super(o,r)}}get[Symbol.toStringTag](){return j}static innerTypes(p,q){return isFunction(c)?c(l,{path:p,Type:q}):Object.freeze(c)}};return o.displayName=j,o},{union:defaultUnion}=metadata$1(),createUnionType=(c,h,j=defaultUnion)=>{const l=c.map((q)=>isPlainObject(q)&&!(q instanceof M.Enum)?q:M.metadata()._(q));h=h===void 0?inferClassifier(l):h;const o=l.length;class p extends M.Base{static caseOf(...q){const r=new Map(q),s=r.size;if(o!==s)throw Error(`caseOf expected ${o} but contains ${s}`);if(!l.every((t)=>r.has(t.type)))throw Error("caseOf does not cover all cases");return(t,u)=>{const w=t[typeSymbol],y=w?w():t.constructor,z=r.get(y),A=z===void 0?u:z;return isFunction(A)?A(t):A}}static metadata(){return j(p,l,h)}}return p},{_}=metadata$1(),internalNonMutators=["set","setIn"],mapNonMutators=internalNonMutators.concat(["delete","clear","update","merge","mergeWith","mergeDeep","mergeDeepWith","map","filter","filterNot","reverse","sort","sortBy","slice","rest","butLast","skip","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","concat","withMutations"]),mapMutators=[],setNonMutators=internalNonMutators.concat(["add","delete","clear","union","merge","intersect","subtract","mergeDeepWith","map","filter","filterNot","reverse","sort","concat","withMutations"]),setMutators=[],listNonMutators=internalNonMutators.concat(["delete","insert","clear","push","pop","unshift","shift","update","merge","mergeWith","mergeDeep","mergeDeepWith","map","filter","filterNot","reverse","sort","sortBy","slice","rest","butLast","skip","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","concat","withMutations"]),listMutators=[],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],proxyMap=partial(proxyFactory,mapNonMutators,mapMutators,identity),genericsFromJS=(c,h,j)=>_(c,h).reviver("",j),fromJS=(c,h)=>genericsFromJS(c,[],h),ajvGenericsFromJS=(c,h,j,l,o)=>c(h,l,j).reviver("",o),ajvFromJS=(c,h,j,l)=>ajvGenericsFromJS(c,h,j,[],l),createAjvModel=(c,h,j={})=>{return j.metadata=ajvMetadata(c),createModel(h,j)},createSimpleModel=(c,h)=>createModel(c,{stringTag:h});var M={about:Object.freeze({version,author,homepage,license}),Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum,EnumMap:EnumMap$1,List:List$2,Map:ModelicoMap$1,StringMap:StringMap$1,Maybe:Maybe$1,Just:Maybe$1.Just,Nothing:Maybe$1.Nothing,Base:Base$1,Set:ModelicoSet$1,createModel,createSimpleModel,createAjvModel,createUnionType,new:(c)=>(h)=>new c(h),fields:(c)=>c[fieldsSymbol](),symbols,fromJS,genericsFromJS,fromJSON:(c,h)=>fromJS(c,JSON.parse(h)),genericsFromJSON:(c,h,j)=>genericsFromJS(c,h,JSON.parse(j)),ajvFromJS,ajvGenericsFromJS,ajvFromJSON:(c,h,j,l)=>ajvFromJS(c,h,j,JSON.parse(l)),ajvGenericsFromJSON:(c,h,j,l,o)=>ajvGenericsFromJS(c,h,j,l,JSON.parse(o)),metadata:metadata$1,ajvMetadata,getSchema,validate,withValidation,withCache,proxyMap,proxyEnumMap:proxyMap,proxyStringMap:proxyMap,proxyList:partial(proxyFactory,listNonMutators,listMutators,identity),proxySet:partial(proxyFactory,setNonMutators,setMutators,identity),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators,identity),util:{T,always,formatAjvError,identity,isNothing,partial,pipe,mem}};export default M;

