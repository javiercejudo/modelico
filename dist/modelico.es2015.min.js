var _NumberisNaN=Number.isNaN,version="22.1.0",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),innerOrigSymbol=Symbol("innerOrig");var symbols=Object.freeze({typeSymbol:typeSymbol,fieldsSymbol:fieldsSymbol,innerOrigSymbol:innerOrigSymbol});const get=(c)=>(h)=>h[c],pipe2=(c,h)=>(...j)=>h(c(...j)),not=(c)=>!c,T=()=>!0,identity=(c)=>c,pipe=(...c)=>[...c,identity].reduce(pipe2),partial=(c,...h)=>c.bind(void 0,...h),asIsReviver=(c)=>(h,j)=>c(j),always=(c)=>()=>c,isNothing=(c)=>null==c||_NumberisNaN(c),isSomething=pipe2(isNothing,not),assertSomethingIdentity=(c)=>{if(isNothing(c))throw TypeError(`expected a value but got nothing (null, undefined or NaN)`);return c},defaultTo=(c)=>(h)=>isNothing(h)?c:h,objToArr=(c)=>Object.keys(c).map((h)=>[h,c[h]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(assertSomethingIdentity))),isPlainObject=(c)=>"object"==typeof c&&!!c,isFunction=(c)=>"function"==typeof c,emptyObject=Object.freeze({}),haveSameValues=(c,h)=>c===h||Object.is(c,h),haveSameType=(c,h)=>null==c||null==h?c===h:c.constructor===h.constructor,haveDifferentTypes=pipe2(haveSameType,not),equals=(c,h)=>isSomething(c)&&c.equals?c.equals(h):haveSameValues(c,h),unsupported=(c)=>{throw Error(c)},innerTypesCache=new WeakMap,getInnerTypes=(c,h)=>{return h.innerTypes(c,h)};var getInnerTypes$1=(c,h)=>{return innerTypesCache.has(h)||innerTypesCache.set(h,getInnerTypes(c,h)),innerTypesCache.get(h)||emptyObject};const metadataSchemaCache=new WeakMap;let state;const defaultState=()=>({nextRef:1,definitions:{},usedDefinitions:new Set,metadataRefCache:new WeakMap}),getSchemaImpl=(c)=>{if(c.schema)return c.schema();const h=c.type&&c.type.innerTypes,j=h?getInnerTypes$1([],c.type):emptyObject;if(0===Object.keys(j).length)return emptyObject;const o=[],p=Object.keys(j).reduce((r,s)=>{const t=j[s],u=getSchema(t,!1);let w;return void 0===t.default?(o.push(s),w=u):w=Object.assign({},{anyOf:[{type:"null"},u]},t.type===M.Maybe?void 0:{default:t.default}),Object.assign(r,{[s]:w})},{}),q=Object.assign({},{type:"object"},{properties:p});return 0<o.length&&(q.required=o),q},getUsedDefinitions=()=>{const{definitions:c,usedDefinitions:h}=state;return Object.keys(c).map(Number).reduce((j,l)=>{return h.has(l)&&(j[l]=c[l]),j},{})},getSchema=(c,h=!0)=>{if(metadataSchemaCache.has(c))return metadataSchemaCache.get(c);if(h&&(state=defaultState()),state.metadataRefCache.has(c)){const q=state.metadataRefCache.get(c)||state.nextRef;return state.usedDefinitions.add(q),{$ref:`#/definitions/${q}`}}const j=state.nextRef;state.metadataRefCache.set(c,j),state.nextRef+=1;const l=getSchemaImpl(c);if(Object.assign(state.definitions,{[j]:l}),!h){const q=state.metadataRefCache.get(c),r=Object.keys(l);return q&&(!(1>=r.length)||Array.isArray(l[r[0]]))?(state.usedDefinitions.add(q),{$ref:`#/definitions/${q}`}):l}const o=getUsedDefinitions();let p;return p=0===Object.keys(o).length?l:o.hasOwnProperty(j)?{definitions:Object.assign(o,{[j]:l}),$ref:`#/definitions/${j}`}:Object.assign({},l,{definitions:o}),metadataSchemaCache.set(c,p),p};var validate=(c,h=[])=>{try{M.genericsFromJSON(c[M.symbols.typeSymbol](),h,JSON.stringify(c))}catch(j){return[!1,j]}return[!0,void 0]};const defaultErrorMsgFn=(c,h)=>`Invalid value at "${h.join(" -> ")}"`;var withValidation=(c,h=defaultErrorMsgFn)=>(j)=>{return Object.assign({},j,{reviver:(o,p,q=[])=>{if(""!==o)return p;const r=j.reviver("",p,q);if(!c(r))throw TypeError(h(r,q));return r}})},asIs=(c=identity)=>Object.freeze({type:c,reviver:asIsReviver(pipe(assertSomethingIdentity,c)),maybeReviver:asIsReviver(c)}),any=always(asIs(identity)),anyOf=(c=[],h="type")=>(j,l)=>{if(0===c.length)return any;const o=c[0][1][typeSymbol](),p=o.metadata().reviver("",j[h]);for(let r=0;r<c.length;r+=1){const s=c[r],t=s[0],u=s[1];if(p===u)return t}const q=l.slice(0,-1);throw TypeError(`unsupported enumerator "${p.toJSON()}" at "${q.join(" -> ")}"`)};const plainObjectReviverFactory=(c,h,j,l)=>Object.keys(j).reduce((o,p)=>{const q=l.concat(p),r=getInnerTypes$1(l,c),s=r[p],t=isFunction(s)?s(j,q):s;return o[p]=t?reviverOrAsIs(t)(h,j[p],q):j[p],o},{}),reviverFactory=(c)=>(h,j,l=[])=>{if(""!==h)return j;const o=isPlainObject(j)?plainObjectReviverFactory(c,h,j,l):j;return new c(o)},getPathReducer=(c,h)=>c.get(h);class Base{constructor(c,h=emptyObject,j){if(!isPlainObject(h))throw TypeError(`expected an object with fields for ${c.displayName||c.name} but got ${h}`);Object.freeze(h);const l={},o=getInnerTypes$1([],c);j=defaultTo(this)(j),j[typeSymbol]=always(c),Object.keys(o).forEach((p)=>{const q=h[p],r=o[p].default;let s;if(isSomething(q))s=q;else if(isSomething(r))s=o[p].default,l[p]=s;else throw TypeError(`no value for key "${p}"`);j[p]=always(s)}),j[fieldsSymbol]=always(Object.freeze(Object.assign(l,h)))}get[Symbol.toStringTag](){return"ModelicoModel"}get(c){return this[fieldsSymbol]()[c]}getIn(c){return c.reduce(getPathReducer,this)}copy(c){const h=Object.assign({},this[fieldsSymbol](),c);return new(this[typeSymbol]())(h)}set(c,h){return this.copy({[c]:h})}setIn(c,h){if(0===c.length)return this.copy(h);const[j,...l]=c,o=this[j]();return o.setIn?this.set(j,o.setIn(l,h)):this.set(j,h)}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const h=this[fieldsSymbol](),j=c[fieldsSymbol](),l=Object.keys(h),o=Object.keys(j);return!(l.length!==o.length)&&l.every((p)=>equals(h[p],j[p]))}toJSON(){return this[fieldsSymbol]()}toJS(){return JSON.parse(JSON.stringify(this))}stringify(c){return JSON.stringify(this,null,c)}static innerTypes(){return emptyObject}static factory(...c){return new Base(...c)}}var Base$1=Object.freeze(Base);const set=(c,h,j,l)=>{const o=c.inner();return o.set(j,l),h.fromMap(o)},of=(c,h)=>{const j=h.length;if(1==j%2)throw TypeError(`${c.displayName}.of requires an even number of arguments`);const l=new Map;for(let o=0;o<j;o+=2)l.set(h[o],h[o+1]);return c.fromMap(l)},metadata$1=(c,h,j,l)=>{return Object.freeze({type:c,subtypes:Object.freeze([j,l]),reviver:h(j,l)})},equalPairs=(c,h)=>c.every((j,l)=>equals(j,h[l])),copy=(c)=>new Map(c);class AbstractMap extends Base$1{constructor(c,h=new Map,j){if(super(c),isNothing(h))throw TypeError("missing map");if(j&&0===h.size)return j;const l=copy(h);this[innerOrigSymbol]=always(l),this.inner=()=>copy(l),this.size=l.size}[Symbol.iterator](){return this[innerOrigSymbol]()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}get(c){return this[innerOrigSymbol]().get(c)}setIn(c,h){if(0===c.length)return new(this[typeSymbol]())(h);const[j,...l]=c,o=this[innerOrigSymbol]().get(j);return o.setIn?this.set(j,o.setIn(l,h)):this.set(j,h)}equals(c,h=!1){if(this===c)return!0;if(haveDifferentTypes(this,c)||this.size!==c.size)return!1;const j=this[Symbol.iterator](),l=c[Symbol.iterator]();for(let o=0;o<this.size;o+=1){const p=j.next().value,q=h?c.has(p[0])&&equals(p[1],c.get(p[0])):equalPairs(p,l.next().value);if(!q)return!1}return!0}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(c,h,j)=>(l,o)=>[c("",l[0],j.concat(o,0)),h("",l[1],j.concat(o,1))],reviverFactory$2=(c,h)=>(j,l,o=[])=>{if(""!==j)return l;const p=reviverOrAsIs(isFunction(c)?c(l,o):c),q=reviverOrAsIs(isFunction(h)?h(l,o):h),r=null===l?null:new Map(l.map(parseMapper(p,q,o)));return ModelicoMap.fromMap(r)};let EMPTY_MAP;class ModelicoMap extends AbstractMap$1{constructor(c){super(ModelicoMap,c,EMPTY_MAP),EMPTY_MAP||0!==this.size||(EMPTY_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMap"}set(c,h){return set(this,ModelicoMap,c,h)}toJSON(){return[...this]}static fromMap(c){return new ModelicoMap(c)}static fromArray(c){return ModelicoMap.fromMap(new Map(c))}static of(...c){return of(ModelicoMap,c)}static fromObject(c){return ModelicoMap.fromArray(objToArr(c))}static metadata(c,h){return metadata$1(ModelicoMap,reviverFactory$2,c,h)}static EMPTY(){return EMPTY_MAP||ModelicoMap.of()}}ModelicoMap.displayName="ModelicoMap";var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(c,h)=>{return c[h[0]]=h[1],c},parseReducer=(c,h,j)=>(l,o)=>[...l,[o,c("",h[o],j.concat(o))]],reviverFactory$3=(c)=>(h,j,l=[])=>{if(""!==h)return j;const o=reviverOrAsIs(isFunction(c)?c(j,l):c),p=null===j?null:new Map(Object.keys(j).reduce(parseReducer(o,j,l),[]));return StringMap.fromMap(p)};let EMPTY_STRING_MAP;class StringMap extends AbstractMap$1{constructor(c){super(StringMap,c,EMPTY_STRING_MAP),EMPTY_STRING_MAP||0!==this.size||(EMPTY_STRING_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoStringMap"}set(c,h){return set(this,StringMap,c,h)}toJSON(){return[...this].reduce(stringifyReducer,{})}static fromMap(c){return new StringMap(c)}static fromArray(c){return StringMap.fromMap(new Map(c))}static of(...c){return of(StringMap,c)}static fromObject(c){return StringMap.fromArray(objToArr(c))}static metadata(c){return metadata$1(StringMap,reviverFactory$3,c)}static EMPTY(){return EMPTY_STRING_MAP||StringMap.of()}}StringMap.displayName="StringMap";var StringMap$1=Object.freeze(StringMap);const stringifyReducer$1=(c,h)=>{return c[h[0].toJSON()]=h[1],c},parseMapper$1=(c,h,j,l)=>(o)=>{const p=c("",o,l),q=h("",j[o],l.concat(o));return[p,q]},reviverFactory$4=(c,h)=>(j,l,o=[])=>{if(""!==j)return l;const p=reviverOrAsIs(isFunction(c)?c(l,o):c),q=reviverOrAsIs(isFunction(h)?h(l,o):h),r=null===l?null:new Map(Object.keys(l).map(parseMapper$1(p,q,l,o)));return new EnumMap(r)};let EMPTY_ENUM_MAP;class EnumMap extends AbstractMap$1{constructor(c){super(EnumMap,c,EMPTY_ENUM_MAP),EMPTY_ENUM_MAP||0!==this.size||(EMPTY_ENUM_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoEnumMap"}set(c,h){return set(this,EnumMap,c,h)}toJSON(){return[...this].reduce(stringifyReducer$1,{})}static fromMap(c){return new EnumMap(c)}static fromArray(c){return EnumMap.fromMap(new Map(c))}static of(...c){return of(EnumMap,c)}static metadata(c,h){return metadata$1(EnumMap,reviverFactory$4,c,h)}static EMPTY(){return EMPTY_ENUM_MAP||EnumMap.of()}}EnumMap.displayName="EnumMap";var EnumMap$1=Object.freeze(EnumMap);const reviver=(c,h)=>{return ModelicoNumber.of(h)};class ModelicoNumber extends Base$1{constructor(c=0){if(super(ModelicoNumber),!_NumberisNaN(c)&&isNothing(c))throw TypeError("missing number");this.inner=always(+c),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoNumber"}set(){unsupported("Number.set is not supported")}setIn(c,h){return 0===c.length?ModelicoNumber.of(h):void unsupported("ModelicoNumber.setIn is not supported for non-empty paths")}toJSON(){const c=this.inner();return Object.is(c,-0)?"-0":c===Infinity?"Infinity":c===-Infinity?"-Infinity":_NumberisNaN(c)?"NaN":c}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&haveSameValues(this.inner(),c.inner())}static of(c){return new ModelicoNumber(c)}static metadata(){return Object.freeze({type:ModelicoNumber,reviver})}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(c,h)=>{const j=null===h?null:new Date(h);return new ModelicoDate(j)};class ModelicoDate extends Base$1{constructor(c=new Date){if(super(ModelicoDate),isNothing(c))throw TypeError("missing date");const h=new Date(c.getTime());this.inner=()=>new Date(h.getTime()),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoDate"}set(){unsupported("Date.set is not supported")}setIn(c,h){return 0===c.length?ModelicoDate.of(h):void unsupported("Date.setIn is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.toJSON()===c.toJSON()}static of(c){return new ModelicoDate(c)}static metadata(){return Object.freeze({type:ModelicoDate,reviver:reviver$1})}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(c,h)=>(j,l,o=[])=>{if(""!==j)return l;const p=Array.isArray(h);if(p&&l.length!==h.length)throw TypeError("tuple has missing or extra items");const q=p?(t)=>isFunction(h[t])?h[t](l,o):h[t]:isFunction(h)?always(h(l,o)):always(h),s=null===l?null:l.map((t,u)=>reviverOrAsIs(q(u))("",t,o.concat(u)));return new c(s)},iterableMetadata=(c,h)=>{return Object.freeze({type:c,subtypes:Object.freeze([h]),reviver:iterableReviverFactory(c,h)})},iterableEquals=(c,h,j=!1)=>{if(c===h)return!0;if(haveDifferentTypes(c,h)||c.size!==h.size)return!1;const l=c[Symbol.iterator](),o=h[Symbol.iterator]();for(let p=0;p<c.size;p+=1){const q=l.next().value;if(j){if(!h.has(q))return!1;}else if(!equals(q,o.next().value))return!1}return!0};let EMPTY_LIST;class List extends Base$1{constructor(c=[]){if(super(List),isNothing(c))throw TypeError("missing list");return EMPTY_LIST&&0===c.length?EMPTY_LIST:void(Object.freeze(c),this.inner=always(c),this[innerOrigSymbol]=this.inner,this.size=c.length,!EMPTY_LIST&&0===this.size&&(EMPTY_LIST=this),Object.freeze(this))}get[Symbol.toStringTag](){return"ModelicoList"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}includes(...c){return this.inner().includes(...c)}get(c){return this.inner()[c]}set(c,h){const j=[...this];return j[c]=h,List.fromArray(j)}setIn(c,h){if(0===c.length)return List.fromArray(h);const[j,...l]=c,o=this.inner()[j];return o.setIn?this.set(j,o.setIn(l,h)):this.set(j,h)}toJSON(){return this.inner()}equals(c){return iterableEquals(this,c)}static fromArray(c){return new List(c)}static of(...c){return List.fromArray(c)}static metadata(c){return iterableMetadata(List,c)}static EMPTY(){return EMPTY_LIST||List.of()}}List.displayName="List";var List$1=Object.freeze(List);let EMPTY_SET;const copy$1=(c)=>new Set(c);class ModelicoSet extends Base$1{constructor(c=new Set){if(super(ModelicoSet),isNothing(c))throw TypeError("missing set");if(EMPTY_SET&&0===c.size)return EMPTY_SET;const h=copy$1(c);this[innerOrigSymbol]=always(h),this.inner=()=>copy$1(h),this.size=h.size,EMPTY_SET||0!==this.size||(EMPTY_SET=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoSet"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}set(){unsupported("Set.set is not supported")}setIn(c,h){return 0===c.length?new ModelicoSet(h):void unsupported("Set.setIn is not supported for non-empty paths")}toJSON(){return[...this]}equals(...c){return iterableEquals(this,...c)}static fromSet(c){return new ModelicoSet(c)}static fromArray(c){return ModelicoSet.fromSet(new Set(c))}static of(...c){return ModelicoSet.fromArray(c)}static metadata(c){return iterableMetadata(ModelicoSet,c)}static EMPTY(){return EMPTY_SET||ModelicoSet.of()}}ModelicoSet.displayName="ModelicoSet";var ModelicoSet$1=Object.freeze(ModelicoSet);const reviverFactory$5=(c)=>(h,j,l)=>{if(""!==h)return j;const o=isFunction(c)?c(j,l):c,p=null===j?always(null):defaultTo(o.reviver)(o.maybeReviver),q=p(h,j,l);return Maybe.of(q)};class Maybe extends Base$1{constructor(){super(Maybe)}get(c){const h=c[0],j=c[1],l=this.getOrElse(h);return l.get?l.get(j):l}set(c,h){if(this.isEmpty())return this;const j=this.inner();if(isNothing(j))return this;const l=j.set?j.set(c,h):null;return Maybe.of(l)}setIn(c,h){if(0===c.length)return Maybe.of(h);const[j,...l]=c,o=j[0],p=j[1],q=this.isEmpty()?o:this.inner(),r=q.setIn?q.setIn([p,...l],h):null;return Maybe.of(r)}static of(c){return isNothing(c)?new Nothing:new Just(c)}static metadata(c){return Object.freeze({type:Maybe,subtypes:[c],reviver:reviverFactory$5(c),default:new Nothing})}}Maybe.displayName="Maybe";let nothing;class Nothing extends Maybe{constructor(){return super(),nothing||(this.inner=always(TypeError("nothing holds no value")),nothing=this),nothing}get[Symbol.toStringTag](){return"ModelicoNothing"}toJSON(){return null}isEmpty(){return!0}getOrElse(c){return c}map(){return this}equals(c){return this===c}}class Just extends Maybe{constructor(c){super(),this.inner=always(c),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoJust"}toJSON(){const c=this.inner();return isNothing(c)?null:c.toJSON?c.toJSON():c}isEmpty(){return!1}getOrElse(){return this.inner()}map(c){return Just.of(c(this.inner()))}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&equals(this.inner(),c.inner())}static of(c){return new Just(c)}}Just.displayName="Just",Maybe.Nothing=new Nothing,Maybe.Just=Just;var Maybe$1=Object.freeze(Maybe);const metadataCache=new WeakMap,base=(c)=>Object.freeze({type:c,reviver:reviverFactory(c)}),raw_=(c,h)=>c.metadata?c.metadata(...h):base(c),_$1=(c,h=[])=>{return 0<h.length?raw_(c,h):(metadataCache.has(c)||metadataCache.set(c,raw_(c,h)),metadataCache.get(c))},metadata=()=>Object.freeze({_:_$1,base,asIs,any,anyOf,number:({wrap:c=!1}={})=>c?ModelicoNumber$1.metadata():asIs(Number),string:always(asIs(String)),boolean:always(asIs(Boolean)),date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$1.metadata,map:ModelicoMap$1.metadata,stringMap:StringMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata,withDefault:(c,h)=>{const j=reviverOrAsIs(c)("",h);return Object.freeze(Object.assign({},c,{default:j}))}}),enumeratorsReducer=(c,h)=>Object.assign(c,{[h]:{code:h}}),reviverFactory$6=(c)=>(h,j,l=[])=>{const o=c[j];if(isNothing(o))throw TypeError(`missing enumerator "${j}" at "${l.join(" -> ")}"`);return o};class Enum extends Base$1{constructor(c,h=Enum,j=h.displayName){const l=Array.isArray(c)?c.reduce(enumeratorsReducer,{}):c;h!==Enum&&(h.displayName=j,Object.freeze(h)),super(h),Object.getOwnPropertyNames(l).forEach((o)=>{this[o]=always(l[o]),l[o][typeSymbol]=always(this),l[o].toJSON=always(o),l[o].equals=(p)=>l[o]===p}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:h,enumerators:l,reviver:reviverFactory$6(l)}))})}static fromObject(...c){return new Enum(...c)}static fromArray(...c){return new Enum(...c)}}Object.defineProperty(Enum,"displayName",{value:"Enum",writable:!0});const proxyToSelf=(c,h,j,l,o)=>{return c.includes(o)?(...p)=>{const q=l[o](...p);return proxyFactory(c,h,j,q)}:l[o]},proxyToInner=(c,h,j,l,o,p,q)=>{return j.includes(q)?(...r)=>{const s=p.setIn([],h.apply(c,r));return proxyFactory(j,l,o,s)}:l.includes(q)?(...r)=>{h.apply(c,r);const s=p.setIn([],c);return proxyFactory(j,l,o,s)}:(...r)=>{return h.apply(c,r)}},proxyFactory=(c,h,j,l)=>{return new Proxy(l,{get:(p,q)=>{if(q in p)return proxyToSelf(c,h,j,p,q);const r=j(p.inner()),s=r[q];return"function"==typeof s?proxyToInner(r,s,c,h,j,p,q):s}})},formatError=(c,h,j,l=[])=>["Invalid JSON at \""+l.join(" -> ")+"\". According to the schema\n",JSON.stringify(h,null,2)+"\n","the value (data path \""+c.errors.filter((o)=>""!==o.dataPath).map((o)=>o.dataPath)+"\")\n",JSON.stringify(j,null,2)+"\n"].concat(c.errors.map((o)=>o.message)).join("\n"),formatDefaultValueError=(c,h,j)=>["Invalid default value. According to the schema\n",JSON.stringify(h,null,2)+"\n","the default value\n",JSON.stringify(j,null,2)+"\n"].concat(c.errors.map((l)=>l.message)).join("\n");var ajvMetadata=(c={validate:T})=>{const h=M.metadata(),j={},{_:l,base:o,asIs:p,any:q,anyOf:r,string:s,number:t,boolean:u,date:w,enumMap:y,list:z,map:A,stringMap:B,set:C,maybe:D,withDefault:E}=h,F=(K,L,N=identity)=>(O,P,Q)=>{if(""!==O)return P;const R=L===emptyObject||c.validate(L,N(P));if(!R)throw TypeError(formatError(c,L,P,Q));const S=isFunction(K)?K(P,Q):K;return S.reviver("",P,Q)},G=(K,L,N)=>(O,P)=>{if(""!==O)return P;const Q=F(K,L)(O,P);return F(q(),N,(R)=>R.inner())(O,Q)},H=(K,L,N=emptyObject,O=always(emptyObject))=>{const P=L===emptyObject&&N===emptyObject?emptyObject:Object.assign({},L,N),Q=F(K,P),S=isFunction(K)?{type:K}:K;return Object.assign({},S,{reviver:Q,ownSchema:always(P),schema:()=>Object.assign({},P,O())})};j.ajvMeta=H,j.ajv_=(K,L=emptyObject,N,O=!1)=>{const P=l(K,N);return H(P,emptyObject,L,()=>getSchema(P,O))},j.ajvBase=(K,L=emptyObject,N=!1)=>{const O=o(K);return H(O,{type:"object"},L,()=>getSchema(O,N))},j.ajvAsIs=(K,L=identity)=>H(p(L),K),j.ajvAny=(K)=>j.ajvAsIs(K),j.ajvNumber=(K,L=emptyObject)=>{const{wrap:N=!1}=L,O=t(L);if(!N)return H(O,{type:"number"},K);const P=Object.assign({type:"number"},K),Q=G(O,{anyOf:[{type:"number"},{enum:["-0","-Infinity","Infinity","NaN"]}]},P);return Object.assign({},O,{reviver:Q,ownSchema:always(P),schema:always(P)})},j.ajvString=(K)=>H(s(),{type:"string"},K),j.ajvBoolean=(K)=>H(u(),{type:"boolean"},K),j.ajvDate=(K)=>H(w(),{type:"string",format:"date-time"},K),j.ajvEnum=(K)=>{const L=l(K);return H(L,{enum:Object.keys(L.enumerators)})},j.ajvEnumMap=(K,L,N)=>{const O=Object.keys(L.enumerators),P=`^(${O.join("|")})$`;return H(y(L,N),{type:"object",maxProperties:O.length,additionalProperties:!1,patternProperties:{[P]:{}}},K,()=>({patternProperties:{[P]:getSchema(N,!1)}}))};const I=(K,L)=>H(z(L),{type:"array"},K,()=>({items:getSchema(L,!1)})),J=(K,L)=>{const N=L.length;return H(z(L),{type:"array",minItems:N,maxItems:N},K,()=>({items:L.map((O)=>getSchema(O,!1))}))};return j.ajvList=(K,L)=>Array.isArray(L)?J(K,L):I(K,L),j.ajvMap=(K,L,N)=>{const O={type:"array",items:{type:"array",minItems:2,maxItems:2}};return H(A(L,N),O,K,()=>({items:Object.assign({items:[getSchema(L,!1),getSchema(N,!1)]},O.items)}))},j.ajvStringMap=(K,L)=>H(B(L),{type:"object"},K,()=>({additionalProperties:!1,patternProperties:{".*":getSchema(L,!1)}})),j.ajvSet=(K,L)=>H(C(L),{type:"array",uniqueItems:!0},K,()=>({items:getSchema(L,!1)})),j.ajvMaybe=(K)=>H(D(K),emptyObject,emptyObject,()=>getSchema(K,!1)),j.ajvWithDefault=(K,L)=>{const N=getSchema(K),O=c.validate(N,L);if(!O)throw TypeError(formatDefaultValueError(c,N,L));return H(E(K,L),{default:L},emptyObject,always(N))},j.ajvAnyOf=(K,L)=>H(r(K,L),{anyOf:K.map((N)=>getSchema(N[0],!1))}),Object.freeze(Object.assign(j,h))};const metadata$2=metadata(),createModel=(c=emptyObject,{base:h=Base$1,stringTag:j="ModelicoModel",metadata:l=metadata$2}={})=>{return class extends h{get[Symbol.toStringTag](){return j}static innerTypes(o,p){return isFunction(c)?c(l,{path:o,Type:p}):Object.freeze(c)}}},{_}=metadata(),internalNonMutators=["set","setIn"],mapNonMutators=internalNonMutators,mapMutators=["delete","clear"],setNonMutators=internalNonMutators,setMutators=["add","delete","clear"],listNonMutators=internalNonMutators.concat(["concat","slice","filter"]),listMutators=["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],proxyMap=partial(proxyFactory,mapNonMutators,mapMutators,identity),genericsFromJS=(c,h,j)=>_(c,h).reviver("",j),fromJS=(c,h)=>genericsFromJS(c,[],h),ajvGenericsFromJS=(c,h,j,l,o)=>c(h,j,l).reviver("",o),ajvFromJS=(c,h,j,l)=>ajvGenericsFromJS(c,h,j,[],l),createAjvModel=(c,h,j={})=>{return j.metadata=ajvMetadata(c),createModel(h,j)};var M={about:Object.freeze({version,author,homepage,license}),Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum,EnumMap:EnumMap$1,List:List$1,Map:ModelicoMap$1,StringMap:StringMap$1,Maybe:Maybe$1,Just:Maybe$1.Just,Nothing:Maybe$1.Nothing,Base:Base$1,Set:ModelicoSet$1,createModel,createAjvModel,fields:(c)=>c[fieldsSymbol](),symbols,fromJS,genericsFromJS,fromJSON:(c,h)=>fromJS(c,JSON.parse(h)),genericsFromJSON:(c,h,j)=>genericsFromJS(c,h,JSON.parse(j)),ajvFromJS,ajvGenericsFromJS,ajvFromJSON:(c,h,j,l)=>ajvFromJS(c,h,j,JSON.parse(l)),ajvGenericsFromJSON:(c,h,j,l,o)=>ajvGenericsFromJS(c,h,j,l,JSON.parse(o)),metadata,ajvMetadata,getSchema,validate,withValidation,proxyMap,proxyEnumMap:proxyMap,proxyStringMap:proxyMap,proxyList:partial(proxyFactory,listNonMutators,listMutators,(c)=>[...c]),proxySet:partial(proxyFactory,setNonMutators,setMutators,identity),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators,identity)};export default M;

