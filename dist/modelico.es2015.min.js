var version="20.0.0",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),innerOrigSymbol=Symbol("innerOrigSymbol");var symbols=Object.freeze({typeSymbol:typeSymbol,fieldsSymbol:fieldsSymbol,innerOrigSymbol:innerOrigSymbol});const get=(c)=>(e)=>e[c],pipe2=(c,e)=>(...g)=>e(c(...g)),not=(c)=>!c,T=()=>!0,identity=(c)=>c,partial=(c,...e)=>c.bind(void 0,...e),asIsReviver=(c)=>(e,g)=>c(g),always=(c)=>()=>c,isNothing=(c)=>null==c||Number.isNaN(c),isSomething=pipe2(isNothing,not),defaultTo=(c)=>(e)=>isNothing(e)?c:e,objToArr=(c)=>Object.keys(c).map(e=>[e,c[e]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(identity))),isPlainObject=(c)=>"object"==typeof c&&!!c,emptyObject=Object.freeze({}),haveSameValues=(c,e)=>c===e||Object.is(c,e),haveSameType=(c,e)=>null==c||null==e?c===e:c.constructor===e.constructor,haveDifferentTypes=pipe2(haveSameType,not),equals=(c,e)=>isSomething(c)&&c.equals?c.equals(e):haveSameValues(c,e),getInnerTypes=(c,e)=>{if(!e.innerTypes)throw Error(`missing static innerTypes for ${e.displayName||e.name}`);return e.innerTypes(c+1,e)},unsupported=(c)=>{throw Error(c)},innerTypesCache=new WeakMap,getInnerTypesWithCache=(c,e)=>{return innerTypesCache.has(e)||innerTypesCache.set(e,getInnerTypes(c,e)),innerTypesCache.get(e)},plainObjectReviverFactory=(c,e,g,h)=>Object.keys(h).reduce((j,l)=>{const m=getInnerTypesWithCache(c,e),o=m[l];return j[l]=o?reviverOrAsIs(o)(g,h[l]):h[l],j},{}),reviverFactory=(c,e)=>(g,h)=>{if(""!==g)return h;const j=isPlainObject(h)?plainObjectReviverFactory(c,e,g,h):h;return new e(j)},getPathReducer=(c,e)=>c.get(e);class Base{constructor(c,e=emptyObject,g){if(!isPlainObject(e))throw TypeError(`expected an object with fields for ${c.displayName||c.name} but got ${e}`);Object.freeze(e);const h={},j=getInnerTypes(0,c);g=defaultTo(this)(g),g[typeSymbol]=always(c),Object.keys(j).forEach(l=>{const m=e[l];let o=M.Maybe.EMPTY;if(isSomething(m))o=m;else if(j[l].type!==M.Maybe)throw TypeError(`no value for key "${l}"`);else h[l]=o;g[l]=always(o)}),g[fieldsSymbol]=always(Object.freeze(Object.assign(h,e)))}get(c){return this[c]()}getIn(c){return c.reduce(getPathReducer,this)}set(c,e){const g=Object.assign({},this[fieldsSymbol](),{[c]:e});return new(this[typeSymbol]())(g)}setIn(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const[g,...h]=c,j=this[g]();return j.setIn?this.set(g,j.setIn(h,e)):this.set(g,e)}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=this[fieldsSymbol](),g=c[fieldsSymbol](),h=Object.keys(e),j=Object.keys(g);return!(h.length!==j.length)&&h.every(l=>equals(e[l],g[l]))}toJSON(){return this[fieldsSymbol]()}toJS(){return JSON.parse(JSON.stringify(this))}stringify(c){return JSON.stringify(this,null,c)}static factory(...c){return new Base(...c)}}var Base$1=Object.freeze(Base);const reviverFactory$2=c=>(e,g)=>{if(""!==e)return g;const h=null===g?null:c.reviver(e,g);return new Maybe(h)};class Nothing{toJSON(){return null}}class Just{constructor(c){this.get=always(c),Object.freeze(this)}toJSON(){const c=this.get();return isNothing(c)?null:c.toJSON?c.toJSON():c}}const nothing=new Nothing;class Maybe extends Base$1{constructor(c,e=!0){super(Maybe);const g=e&&isNothing(c)?nothing:new Just(c);this.inner=always(g),Object.freeze(this)}get(c){const e=c[0],g=c[1],h=this.getOrElse(e);return h.get?h.get(g):h}set(c,e){if(this.isEmpty())return this;const g=this.inner().get();if(isNothing(g))return this;const h=g.set?g.set(c,e):null;return new Maybe(h)}setIn(c,e){if(0===c.length)return Maybe.of(e);const[g,...h]=c,j=g[0],l=g[1],m=this.isEmpty()?j:this.inner().get(),o=m.setIn?m.setIn([l,...h],e):null;return Maybe.of(o)}isEmpty(){return this.inner()===nothing}getOrElse(c){return this.isEmpty()?c:this.inner().get()}map(c){return this.isEmpty()?this:Maybe.ofAny(c(this.inner().get()))}toJSON(){return this.inner().toJSON()}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=this.inner(),g=c.inner();return this.isEmpty()||c.isEmpty()?e===g:equals(e.get(),g.get())}static of(c){return new Maybe(c)}static ofAny(c){return new Maybe(c,!1)}static metadata(c){return Object.freeze({type:Maybe,subtypes:[c],reviver:reviverFactory$2(c)})}static innerTypes(){return emptyObject}}Maybe.displayName="Maybe",Maybe.EMPTY=Maybe.of();var Maybe$1=Object.freeze(Maybe);const enumeratorsReducer=(c,e)=>Object.assign(c,{[e]:{code:e}}),reviverFactory$3=c=>(e,g)=>{const h=c[g];if(isNothing(h))throw TypeError(`missing enumerator (${g})`);return h};class Enum extends Base$1{constructor(c,e=Enum,g=e.displayName){const h=Array.isArray(c)?c.reduce(enumeratorsReducer,{}):c;e!==Enum&&(e.displayName=g,Object.freeze(e)),super(e),Object.getOwnPropertyNames(h).forEach(j=>{this[j]=always(h[j]),h[j].toJSON=always(j),h[j].equals=l=>h[j]===l}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:e,reviver:reviverFactory$3(h)}))})}static fromObject(...c){return new Enum(...c)}static fromArray(...c){return new Enum(...c)}static innerTypes(){return emptyObject}}Object.defineProperty(Enum,"displayName",{value:"Enum",writable:!0});const set=(c,e,g,h)=>{const j=c.inner();return j.set(g,h),e.fromMap(j)},of=(c,e)=>{const g=e.length;if(1==g%2)throw TypeError(`${c.displayName}.of requires an even number of arguments`);const h=new Map;for(let j=0;j<g;j+=2)h.set(e[j],e[j+1]);return c.fromMap(h)},metadata$1=(c,e,g,h)=>{return Object.freeze({type:c,subtypes:Object.freeze([g,h]),reviver:e(g,h)})},equalPairs=(c,e)=>c.every((g,h)=>equals(g,e[h])),copy=c=>new Map(c);class AbstractMap extends Base$1{constructor(c,e=new Map,g){if(super(c),isNothing(e))throw TypeError("missing map");if(g&&0===e.size)return g;const h=copy(e);this[innerOrigSymbol]=always(h),this.inner=()=>copy(h),this.size=h.size,this[Symbol.iterator]=()=>h[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}get(c){return this[innerOrigSymbol]().get(c)}setIn(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const[g,...h]=c,j=this[innerOrigSymbol]().get(g);return j.setIn?this.set(g,j.setIn(h,e)):this.set(g,e)}equals(c,e=!1){if(this===c)return!0;if(haveDifferentTypes(this,c)||this.size!==c.size)return!1;const g=this[Symbol.iterator](),h=c[Symbol.iterator]();for(let j=0;j<this.size;j+=1){const l=g.next().value,m=e?c.has(l[0])&&equals(l[1],c.get(l[0])):equalPairs(l,h.next().value);if(!m)return!1}return!0}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(c,e)=>g=>[c("",g[0]),e("",g[1])],reviverFactory$4=(c,e)=>(g,h)=>{if(""!==g)return h;const j=reviverOrAsIs(c),l=reviverOrAsIs(e),m=null===h?null:new Map(h.map(parseMapper(j,l)));return ModelicoMap.fromMap(m)};let EMPTY_MAP;class ModelicoMap extends AbstractMap$1{constructor(c){super(ModelicoMap,c,EMPTY_MAP),EMPTY_MAP||0!==this.size||(EMPTY_MAP=this),Object.freeze(this)}set(c,e){return set(this,ModelicoMap,c,e)}toJSON(){return[...this]}static fromMap(c){return new ModelicoMap(c)}static fromArray(c){return ModelicoMap.fromMap(new Map(c))}static of(...c){return of(ModelicoMap,c)}static fromObject(c){return ModelicoMap.fromArray(objToArr(c))}static metadata(c,e){return metadata$1(ModelicoMap,reviverFactory$4,c,e)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_MAP||ModelicoMap.of()}}ModelicoMap.displayName="ModelicoMap";var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(c,e)=>{return c[e[0]]=e[1],c},parseReducer=(c,e)=>(g,h)=>[...g,[h,c("",e[h])]],reviverFactory$5=c=>(e,g)=>{if(""!==e)return g;const h=reviverOrAsIs(c),j=null===g?null:new Map(Object.keys(g).reduce(parseReducer(h,g),[]));return StringMap.fromMap(j)};let EMPTY_STRING_MAP;class StringMap extends AbstractMap$1{constructor(c){super(StringMap,c,EMPTY_STRING_MAP),EMPTY_STRING_MAP||0!==this.size||(EMPTY_STRING_MAP=this),Object.freeze(this)}set(c,e){return set(this,StringMap,c,e)}toJSON(){return[...this].reduce(stringifyReducer,{})}static fromMap(c){return new StringMap(c)}static fromArray(c){return StringMap.fromMap(new Map(c))}static of(...c){return of(StringMap,c)}static fromObject(c){return StringMap.fromArray(objToArr(c))}static metadata(c){return metadata$1(StringMap,reviverFactory$5,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_STRING_MAP||StringMap.of()}}StringMap.displayName="StringMap";var StringMap$1=Object.freeze(StringMap);const stringifyReducer$1=(c,e)=>{return c[e[0].toJSON()]=e[1],c},parseMapper$1=(c,e,g)=>h=>{const j=c("",h),l=e("",g[h]);return[j,l]},reviverFactory$6=(c,e)=>(g,h)=>{if(""!==g)return h;const j=reviverOrAsIs(c),l=reviverOrAsIs(e),m=null===h?null:new Map(Object.keys(h).map(parseMapper$1(j,l,h)));return new EnumMap(m)};let EMPTY_ENUM_MAP;class EnumMap extends AbstractMap$1{constructor(c){super(EnumMap,c,EMPTY_ENUM_MAP),EMPTY_ENUM_MAP||0!==this.size||(EMPTY_ENUM_MAP=this),Object.freeze(this)}set(c,e){return set(this,EnumMap,c,e)}toJSON(){return[...this].reduce(stringifyReducer$1,{})}static fromMap(c){return new EnumMap(c)}static fromArray(c){return EnumMap.fromMap(new Map(c))}static of(...c){return of(EnumMap,c)}static metadata(c,e){return metadata$1(EnumMap,reviverFactory$6,c,e)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_ENUM_MAP||EnumMap.of()}}EnumMap.displayName="EnumMap";var EnumMap$1=Object.freeze(EnumMap);const reviver=(c,e)=>{return ModelicoNumber.of(e)};class ModelicoNumber extends Base$1{constructor(c=0){if(super(ModelicoNumber),!Number.isNaN(c)&&isNothing(c))throw TypeError("missing number");this.inner=always(+c),Object.freeze(this)}set(){unsupported("Number.set is not supported")}setIn(c,e){return 0===c.length?ModelicoNumber.of(e):void unsupported("ModelicoNumber.setIn is not supported for non-empty paths")}toJSON(){const c=this.inner();return Object.is(c,-0)?"-0":c===Infinity?"Infinity":c===-Infinity?"-Infinity":Number.isNaN(c)?"NaN":c}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&haveSameValues(this.inner(),c.inner())}static of(c){return new ModelicoNumber(c)}static metadata(){return Object.freeze({type:ModelicoNumber,reviver})}static innerTypes(){return emptyObject}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(c,e)=>{const g=null===e?null:new Date(e);return new ModelicoDate(g)};class ModelicoDate extends Base$1{constructor(c=new Date){if(super(ModelicoDate),isNothing(c))throw TypeError("missing date");const e=new Date(c.getTime());this.inner=()=>new Date(e.getTime()),Object.freeze(this)}set(){unsupported("Date.set is not supported")}setIn(c,e){return 0===c.length?ModelicoDate.of(e):void unsupported("Date.setIn is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.toJSON()===c.toJSON()}static of(c){return new ModelicoDate(c)}static metadata(){return Object.freeze({type:ModelicoDate,reviver:reviver$1})}static innerTypes(){return emptyObject}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(c,e)=>(g,h)=>{if(""!==g)return h;const j=partial(reviverOrAsIs(e),g),l=null===h?null:h.map(j);return new c(l)},iterableMetadata=(c,e)=>{return Object.freeze({type:c,subtypes:Object.freeze([e]),reviver:iterableReviverFactory(c,e)})},iterableEquals=(c,e,g=!1)=>{if(c===e)return!0;if(haveDifferentTypes(c,e)||c.size!==e.size)return!1;const h=c[Symbol.iterator](),j=e[Symbol.iterator]();for(let l=0;l<c.size;l+=1){const m=h.next().value;if(g){if(!e.has(m))return!1;}else if(!equals(m,j.next().value))return!1}return!0};let EMPTY_LIST;class List extends Base$1{constructor(c=[]){if(super(List),isNothing(c))throw TypeError("missing list");return EMPTY_LIST&&0===c.length?EMPTY_LIST:void(Object.freeze(c),this.inner=always(c),this.size=c.length,this[Symbol.iterator]=()=>c[Symbol.iterator](),!EMPTY_LIST&&0===this.size&&(EMPTY_LIST=this),Object.freeze(this))}includes(...c){return this.inner().includes(...c)}get(c){return this.inner()[c]}set(c,e){const g=[...this];return g[c]=e,List.fromArray(g)}setIn(c,e){if(0===c.length)return List.fromArray(e);const[g,...h]=c,j=this.inner()[g];return j.setIn?this.set(g,j.setIn(h,e)):this.set(g,e)}toJSON(){return this.inner()}equals(c){return iterableEquals(this,c)}static fromArray(c){return new List(c)}static of(...c){return List.fromArray(c)}static metadata(c){return iterableMetadata(List,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_LIST||List.of()}}List.displayName="List";var List$1=Object.freeze(List);let EMPTY_SET;const copy$1=c=>new Set(c);class ModelicoSet extends Base$1{constructor(c=new Set){if(super(ModelicoSet),isNothing(c))throw TypeError("missing set");if(EMPTY_SET&&0===c.size)return EMPTY_SET;const e=copy$1(c);this[innerOrigSymbol]=always(e),this.inner=()=>copy$1(e),this.size=e.size,this[Symbol.iterator]=()=>e[Symbol.iterator](),EMPTY_SET||0!==this.size||(EMPTY_SET=this),Object.freeze(this)}has(c){return this[innerOrigSymbol]().has(c)}set(){unsupported("Set.set is not supported")}setIn(c,e){return 0===c.length?new ModelicoSet(e):void unsupported("Set.setIn is not supported for non-empty paths")}toJSON(){return[...this]}equals(...c){return iterableEquals(this,...c)}static fromSet(c){return new ModelicoSet(c)}static fromArray(c){return ModelicoSet.fromSet(new Set(c))}static of(...c){return ModelicoSet.fromArray(c)}static metadata(c){return iterableMetadata(ModelicoSet,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_SET||ModelicoSet.of()}}ModelicoSet.displayName="ModelicoSet";var ModelicoSet$1=Object.freeze(ModelicoSet);const proxyToSelf=(c,e,g,h,j)=>{return c.includes(j)?(...l)=>{const m=h[j](...l);return proxyFactory(c,e,g,m)}:h[j]},proxyToInner=(c,e,g,h,j,l,m)=>{return g.includes(m)?(...o)=>{const p=l.setIn([],e.apply(c,o));return proxyFactory(g,h,j,p)}:h.includes(m)?(...o)=>{e.apply(c,o);const p=l.setIn([],c);return proxyFactory(g,h,j,p)}:(...o)=>{return e.apply(c,o)}},proxyFactory=(c,e,g,h)=>{return new Proxy(h,{get:(l,m)=>{if(m in l)return proxyToSelf(c,e,g,l,m);const o=g(l.inner()),p=o[m];return"function"==typeof p?proxyToInner(o,p,c,e,g,l,m):p}})},formatError=(c,e,g)=>["Invalid JSON: according to the schema\n",JSON.stringify(e,null,2)+"\n","the value\n",JSON.stringify(g,null,2)+"\n",c.errors[0].message].join("\n");var ajvMetadata=(c={validate:T})=>{const{_:e,asIs:g,any:h,string:j,number:l,boolean:m,date:o,enumMap:p,list:q,map:r,stringMap:s,set:t,maybe:u}=M.metadata(),w=(N,O,P=identity)=>(Q,R)=>{if(""!==Q)return R;const S=c.validate(O,P(R));if(!S)throw TypeError(formatError(c,O,R));return N.reviver("",R)},y=(N,O,P)=>(Q,R)=>{if(""!==Q)return R;const S=w(N,O)(Q,R);return w(h(),P,U=>U.inner())(Q,S)},z=(N,O,P={})=>{const Q=Object.assign({},O,P),R=w(N,Q);return Object.assign({},N,{reviver:R})},B=(N,O=identity)=>z(g(O),N);return Object.freeze({_:(N,O)=>z(e(N),O),asIs:B,any:N=>B(N),number:(N,O={})=>{const{wrap:P=!1}=O,Q=l(O);if(!P)return z(Q,{type:"number"},N);const R=y(Q,{anyOf:[{type:"number"},{type:"string",enum:["-0","-Infinity","Infinity","NaN"]}]},Object.assign({},{type:"number"},N));return Object.assign({},Q,{reviver:R})},string:N=>z(j(),{type:"string"},N),boolean:N=>z(m(),{type:"boolean"},N),date:N=>z(o(),{type:"string",format:"date-time"},N),enumMap:(N,O,P)=>z(p(O,P),{type:"object",maxProperties:Object.keys(O).length},N),list:(N,O)=>z(q(O),{type:"array"},N),map:(N,O,P)=>z(r(O,P),{type:"array",items:{type:"array",minItems:2,maxItems:2}},N),stringMap:(N,O)=>z(s(O),{type:"object"},N),set:(N,O)=>z(t(O),{type:"array",uniqueItems:!0},N),maybe:u})},asIs=(c=identity)=>Object.freeze({type:c,reviver:asIsReviver(c)});const internalNonMutators=["set","setIn"],mapNonMutators=internalNonMutators,mapMutators=["delete","clear"],setNonMutators=internalNonMutators,setMutators=["add","delete","clear"],listNonMutators=internalNonMutators.concat(["concat","slice","filter"]),listMutators=["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],_=function(c,e=0,g=[]){return c.metadata?c.metadata(...g):Object.freeze({type:c,reviver:reviverFactory(e,c)})},metadata=()=>Object.freeze({_,asIs,any:always(asIs(identity)),number:({wrap:c=!1}={})=>c?ModelicoNumber$1.metadata():asIs(Number),string:always(asIs(String)),boolean:always(asIs(Boolean)),date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$1.metadata,map:ModelicoMap$1.metadata,stringMap:StringMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata}),proxyMap=partial(proxyFactory,mapNonMutators,mapMutators,identity);var M={about:Object.freeze({version,author,homepage,license}),Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum,EnumMap:EnumMap$1,List:List$1,Map:ModelicoMap$1,StringMap:StringMap$1,Maybe:Maybe$1,Base:Base$1,Set:ModelicoSet$1,fields:c=>c[fieldsSymbol](),symbols,fromJSON:(c,e)=>JSON.parse(e,_(c).reviver),fromJS:(c,e)=>_(c).reviver("",e),genericsFromJSON:(c,e,g)=>JSON.parse(g,_(c,0,e).reviver),genericsFromJS:(c,e,g)=>_(c,0,e).reviver("",g),metadata,ajvMetadata,proxyMap,proxyEnumMap:proxyMap,proxyStringMap:proxyMap,proxyList:partial(proxyFactory,listNonMutators,listMutators,c=>[...c]),proxySet:partial(proxyFactory,setNonMutators,setMutators,identity),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators,identity)};export default M;

