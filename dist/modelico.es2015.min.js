var version="21.2.1",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),innerOrigSymbol=Symbol("innerOrigSymbol");var symbols=Object.freeze({typeSymbol:typeSymbol,fieldsSymbol:fieldsSymbol,innerOrigSymbol:innerOrigSymbol});const get=(c)=>(e)=>e[c],pipe2=(c,e)=>(...h)=>e(c(...h)),not=(c)=>!c,T=()=>!0,identity=(c)=>c,partial=(c,...e)=>c.bind(void 0,...e),asIsReviver=(c)=>(e,h)=>c(h),always=(c)=>()=>c,isNothing=(c)=>null==c||Number.isNaN(c),isSomething=pipe2(isNothing,not),defaultTo=(c)=>(e)=>isNothing(e)?c:e,objToArr=(c)=>Object.keys(c).map((e)=>[e,c[e]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(identity))),isPlainObject=(c)=>"object"==typeof c&&!!c,emptyObject=Object.freeze({}),haveSameValues=(c,e)=>c===e||Object.is(c,e),haveSameType=(c,e)=>null==c||null==e?c===e:c.constructor===e.constructor,haveDifferentTypes=pipe2(haveSameType,not),equals=(c,e)=>isSomething(c)&&c.equals?c.equals(e):haveSameValues(c,e),unsupported=(c)=>{throw Error(c)},innerTypesCache=new WeakMap,getInnerTypes=(c,e)=>{if(!e.innerTypes)throw Error(`missing static innerTypes for ${e.displayName||e.name}`);return e.innerTypes(c,e)};var getInnerTypes$1=(c,e)=>{return innerTypesCache.has(e)||innerTypesCache.set(e,getInnerTypes(c,e)),innerTypesCache.get(e)};const plainObjectReviverFactory=(c,e,h,j)=>Object.keys(h).reduce((l,m)=>{const o=j.concat(m),p=getInnerTypes$1(j,c),q=p[m];return l[m]=q?reviverOrAsIs(q)(e,h[m],o):h[m],l},{}),reviverFactory=(c)=>(e,h,j=[])=>{if(""!==e)return h;const l=isPlainObject(h)?plainObjectReviverFactory(c,e,h,j):h;return new c(l)},metadataSchemaCache=new WeakMap,getSchema=(c)=>{if(c.schema)return c.schema();if(!c.type.innerTypes||0===Object.keys(getInnerTypes$1([],c.type)).length)return emptyObject;const h=c.type.innerTypes(),j=[],l=Object.keys(h).reduce((o,p)=>{const q=h[p],r=getSchema(q);return q.type!==M.Maybe&&void 0===q.default&&j.push(p),Object.assign(o,{[p]:r})},{}),m=Object.assign({},{type:"object"},{properties:l});return 0<j.length&&(m.required=j),m};var getSchema$1=(c)=>{return metadataSchemaCache.has(c)||metadataSchemaCache.set(c,getSchema(c)),metadataSchemaCache.get(c)};const defaultErrorMsgFn=(c,e)=>`Invalid value at "${e.join(" > ")}"`;var withValidation=(c,e=defaultErrorMsgFn)=>(h)=>{return Object.assign({},h,{reviver:(l,m,o=[])=>{if(""!==l)return m;const p=h.reviver("",m,o);if(!c(p))throw TypeError(e(p,o));return p}})};const getPathReducer=(c,e)=>c.get(e);class Base{constructor(c,e=emptyObject,h){if(!isPlainObject(e))throw TypeError(`expected an object with fields for ${c.displayName||c.name} but got ${e}`);Object.freeze(e);const j={},l=getInnerTypes$1([],c);h=defaultTo(this)(h),h[typeSymbol]=always(c),Object.keys(l).forEach((m)=>{const o=e[m],p=l[m].default;let q;if(isSomething(o))q=o;else if(isSomething(p))q=l[m].default,j[m]=q;else throw TypeError(`no value for key "${m}"`);h[m]=always(q)}),h[fieldsSymbol]=always(Object.freeze(Object.assign(j,e)))}get[Symbol.toStringTag](){return"ModelicoModel"}get(c){return this[fieldsSymbol]()[c]}getIn(c){return c.reduce(getPathReducer,this)}set(c,e){const h=Object.assign({},this[fieldsSymbol](),{[c]:e});return new(this[typeSymbol]())(h)}setIn(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const[h,...j]=c,l=this[h]();return l.setIn?this.set(h,l.setIn(j,e)):this.set(h,e)}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=this[fieldsSymbol](),h=c[fieldsSymbol](),j=Object.keys(e),l=Object.keys(h);return!(j.length!==l.length)&&j.every((m)=>equals(e[m],h[m]))}toJSON(){return this[fieldsSymbol]()}toJS(){return JSON.parse(JSON.stringify(this))}stringify(c){return JSON.stringify(this,null,c)}static factory(...c){return new Base(...c)}}var Base$1=Object.freeze(Base);const reviverFactory$2=(c)=>(e,h,j)=>{if(""!==e)return h;const l=null===h?null:c.reviver(e,h,j);return new Maybe(l)};class Nothing{toJSON(){return null}}class Just{constructor(c){this.get=always(c),Object.freeze(this)}toJSON(){const c=this.get();return isNothing(c)?null:c.toJSON?c.toJSON():c}}const nothing=new Nothing;class Maybe extends Base$1{constructor(c,e=!0){super(Maybe);const h=e&&isNothing(c)?nothing:new Just(c);this.inner=always(h),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMaybe"}get(c){const e=c[0],h=c[1],j=this.getOrElse(e);return j.get?j.get(h):j}set(c,e){if(this.isEmpty())return this;const h=this.inner().get();if(isNothing(h))return this;const j=h.set?h.set(c,e):null;return new Maybe(j)}setIn(c,e){if(0===c.length)return Maybe.of(e);const[h,...j]=c,l=h[0],m=h[1],o=this.isEmpty()?l:this.inner().get(),p=o.setIn?o.setIn([m,...j],e):null;return Maybe.of(p)}isEmpty(){return this.inner()===nothing}getOrElse(c){return this.isEmpty()?c:this.inner().get()}map(c){return this.isEmpty()?this:Maybe.ofAny(c(this.inner().get()))}toJSON(){return this.inner().toJSON()}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=this.inner(),h=c.inner();return this.isEmpty()||c.isEmpty()?e===h:equals(e.get(),h.get())}static of(c){return new Maybe(c)}static ofAny(c){return new Maybe(c,!1)}static metadata(c){return Object.freeze({type:Maybe,subtypes:[c],reviver:reviverFactory$2(c),default:Maybe.of()})}static innerTypes(){return emptyObject}}Maybe.displayName="Maybe",Maybe.EMPTY=Maybe.of();var Maybe$1=Object.freeze(Maybe);const enumeratorsReducer=(c,e)=>Object.assign(c,{[e]:{code:e}}),reviverFactory$3=(c)=>(e,h,j=[])=>{const l=c[h];if(isNothing(l))throw TypeError(`missing enumerator "${h}" at "${j.join(" > ")}"`);return l};class Enum extends Base$1{constructor(c,e=Enum,h=e.displayName){const j=Array.isArray(c)?c.reduce(enumeratorsReducer,{}):c;e!==Enum&&(e.displayName=h,Object.freeze(e)),super(e),Object.getOwnPropertyNames(j).forEach((l)=>{this[l]=always(j[l]),j[l].toJSON=always(l),j[l].equals=(m)=>j[l]===m}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:e,enumerators:j,reviver:reviverFactory$3(j)}))})}static fromObject(...c){return new Enum(...c)}static fromArray(...c){return new Enum(...c)}static innerTypes(){return emptyObject}}Object.defineProperty(Enum,"displayName",{value:"Enum",writable:!0});const set=(c,e,h,j)=>{const l=c.inner();return l.set(h,j),e.fromMap(l)},of=(c,e)=>{const h=e.length;if(1==h%2)throw TypeError(`${c.displayName}.of requires an even number of arguments`);const j=new Map;for(let l=0;l<h;l+=2)j.set(e[l],e[l+1]);return c.fromMap(j)},metadata$1=(c,e,h,j)=>{return Object.freeze({type:c,subtypes:Object.freeze([h,j]),reviver:e(h,j)})},equalPairs=(c,e)=>c.every((h,j)=>equals(h,e[j])),copy=(c)=>new Map(c);class AbstractMap extends Base$1{constructor(c,e=new Map,h){if(super(c),isNothing(e))throw TypeError("missing map");if(h&&0===e.size)return h;const j=copy(e);this[innerOrigSymbol]=always(j),this.inner=()=>copy(j),this.size=j.size}[Symbol.iterator](){return this[innerOrigSymbol]()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}get(c){return this[innerOrigSymbol]().get(c)}setIn(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const[h,...j]=c,l=this[innerOrigSymbol]().get(h);return l.setIn?this.set(h,l.setIn(j,e)):this.set(h,e)}equals(c,e=!1){if(this===c)return!0;if(haveDifferentTypes(this,c)||this.size!==c.size)return!1;const h=this[Symbol.iterator](),j=c[Symbol.iterator]();for(let l=0;l<this.size;l+=1){const m=h.next().value,o=e?c.has(m[0])&&equals(m[1],c.get(m[0])):equalPairs(m,j.next().value);if(!o)return!1}return!0}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(c,e,h)=>(j,l)=>[c("",j[0],h.concat(l,0)),e("",j[1],h.concat(l,1))],reviverFactory$4=(c,e)=>(h,j,l=[])=>{if(""!==h)return j;const m=reviverOrAsIs(c),o=reviverOrAsIs(e),p=null===j?null:new Map(j.map(parseMapper(m,o,l)));return ModelicoMap.fromMap(p)};let EMPTY_MAP;class ModelicoMap extends AbstractMap$1{constructor(c){super(ModelicoMap,c,EMPTY_MAP),EMPTY_MAP||0!==this.size||(EMPTY_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoMap"}set(c,e){return set(this,ModelicoMap,c,e)}toJSON(){return[...this]}static fromMap(c){return new ModelicoMap(c)}static fromArray(c){return ModelicoMap.fromMap(new Map(c))}static of(...c){return of(ModelicoMap,c)}static fromObject(c){return ModelicoMap.fromArray(objToArr(c))}static metadata(c,e){return metadata$1(ModelicoMap,reviverFactory$4,c,e)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_MAP||ModelicoMap.of()}}ModelicoMap.displayName="ModelicoMap";var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(c,e)=>{return c[e[0]]=e[1],c},parseReducer=(c,e,h)=>(j,l)=>[...j,[l,c("",e[l],h.concat(l))]],reviverFactory$5=(c)=>(e,h,j=[])=>{if(""!==e)return h;const l=reviverOrAsIs(c),m=null===h?null:new Map(Object.keys(h).reduce(parseReducer(l,h,j),[]));return StringMap.fromMap(m)};let EMPTY_STRING_MAP;class StringMap extends AbstractMap$1{constructor(c){super(StringMap,c,EMPTY_STRING_MAP),EMPTY_STRING_MAP||0!==this.size||(EMPTY_STRING_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoStringMap"}set(c,e){return set(this,StringMap,c,e)}toJSON(){return[...this].reduce(stringifyReducer,{})}static fromMap(c){return new StringMap(c)}static fromArray(c){return StringMap.fromMap(new Map(c))}static of(...c){return of(StringMap,c)}static fromObject(c){return StringMap.fromArray(objToArr(c))}static metadata(c){return metadata$1(StringMap,reviverFactory$5,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_STRING_MAP||StringMap.of()}}StringMap.displayName="StringMap";var StringMap$1=Object.freeze(StringMap);const stringifyReducer$1=(c,e)=>{return c[e[0].toJSON()]=e[1],c},parseMapper$1=(c,e,h,j)=>(l)=>{const m=c("",l,j),o=e("",h[l],j.concat(l));return[m,o]},reviverFactory$6=(c,e)=>(h,j,l=[])=>{if(""!==h)return j;const m=reviverOrAsIs(c),o=reviverOrAsIs(e),p=null===j?null:new Map(Object.keys(j).map(parseMapper$1(m,o,j,l)));return new EnumMap(p)};let EMPTY_ENUM_MAP;class EnumMap extends AbstractMap$1{constructor(c){super(EnumMap,c,EMPTY_ENUM_MAP),EMPTY_ENUM_MAP||0!==this.size||(EMPTY_ENUM_MAP=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoEnumMap"}set(c,e){return set(this,EnumMap,c,e)}toJSON(){return[...this].reduce(stringifyReducer$1,{})}static fromMap(c){return new EnumMap(c)}static fromArray(c){return EnumMap.fromMap(new Map(c))}static of(...c){return of(EnumMap,c)}static metadata(c,e){return metadata$1(EnumMap,reviverFactory$6,c,e)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_ENUM_MAP||EnumMap.of()}}EnumMap.displayName="EnumMap";var EnumMap$1=Object.freeze(EnumMap);const reviver=(c,e)=>{return ModelicoNumber.of(e)};class ModelicoNumber extends Base$1{constructor(c=0){if(super(ModelicoNumber),!Number.isNaN(c)&&isNothing(c))throw TypeError("missing number");this.inner=always(+c),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoNumber"}set(){unsupported("Number.set is not supported")}setIn(c,e){return 0===c.length?ModelicoNumber.of(e):void unsupported("ModelicoNumber.setIn is not supported for non-empty paths")}toJSON(){const c=this.inner();return Object.is(c,-0)?"-0":c===Infinity?"Infinity":c===-Infinity?"-Infinity":Number.isNaN(c)?"NaN":c}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&haveSameValues(this.inner(),c.inner())}static of(c){return new ModelicoNumber(c)}static metadata(){return Object.freeze({type:ModelicoNumber,reviver})}static innerTypes(){return emptyObject}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(c,e)=>{const h=null===e?null:new Date(e);return new ModelicoDate(h)};class ModelicoDate extends Base$1{constructor(c=new Date){if(super(ModelicoDate),isNothing(c))throw TypeError("missing date");const e=new Date(c.getTime());this.inner=()=>new Date(e.getTime()),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoDate"}set(){unsupported("Date.set is not supported")}setIn(c,e){return 0===c.length?ModelicoDate.of(e):void unsupported("Date.setIn is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.toJSON()===c.toJSON()}static of(c){return new ModelicoDate(c)}static metadata(){return Object.freeze({type:ModelicoDate,reviver:reviver$1})}static innerTypes(){return emptyObject}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(c,e)=>(h,j,l=[])=>{if(""!==h)return j;const o=null===j?null:j.map((p,q)=>reviverOrAsIs(e)("",p,l.concat(q)));return new c(o)},iterableMetadata=(c,e)=>{return Object.freeze({type:c,subtypes:Object.freeze([e]),reviver:iterableReviverFactory(c,e)})},iterableEquals=(c,e,h=!1)=>{if(c===e)return!0;if(haveDifferentTypes(c,e)||c.size!==e.size)return!1;const j=c[Symbol.iterator](),l=e[Symbol.iterator]();for(let m=0;m<c.size;m+=1){const o=j.next().value;if(h){if(!e.has(o))return!1;}else if(!equals(o,l.next().value))return!1}return!0};let EMPTY_LIST;class List extends Base$1{constructor(c=[]){if(super(List),isNothing(c))throw TypeError("missing list");return EMPTY_LIST&&0===c.length?EMPTY_LIST:void(Object.freeze(c),this.inner=always(c),this[innerOrigSymbol]=this.inner,this.size=c.length,!EMPTY_LIST&&0===this.size&&(EMPTY_LIST=this),Object.freeze(this))}get[Symbol.toStringTag](){return"ModelicoList"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}includes(...c){return this.inner().includes(...c)}get(c){return this.inner()[c]}set(c,e){const h=[...this];return h[c]=e,List.fromArray(h)}setIn(c,e){if(0===c.length)return List.fromArray(e);const[h,...j]=c,l=this.inner()[h];return l.setIn?this.set(h,l.setIn(j,e)):this.set(h,e)}toJSON(){return this.inner()}equals(c){return iterableEquals(this,c)}static fromArray(c){return new List(c)}static of(...c){return List.fromArray(c)}static metadata(c){return iterableMetadata(List,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_LIST||List.of()}}List.displayName="List";var List$1=Object.freeze(List);let EMPTY_SET;const copy$1=(c)=>new Set(c);class ModelicoSet extends Base$1{constructor(c=new Set){if(super(ModelicoSet),isNothing(c))throw TypeError("missing set");if(EMPTY_SET&&0===c.size)return EMPTY_SET;const e=copy$1(c);this[innerOrigSymbol]=always(e),this.inner=()=>copy$1(e),this.size=e.size,EMPTY_SET||0!==this.size||(EMPTY_SET=this),Object.freeze(this)}get[Symbol.toStringTag](){return"ModelicoSet"}[Symbol.iterator](){return this.inner()[Symbol.iterator]()}has(c){return this[innerOrigSymbol]().has(c)}set(){unsupported("Set.set is not supported")}setIn(c,e){return 0===c.length?new ModelicoSet(e):void unsupported("Set.setIn is not supported for non-empty paths")}toJSON(){return[...this]}equals(...c){return iterableEquals(this,...c)}static fromSet(c){return new ModelicoSet(c)}static fromArray(c){return ModelicoSet.fromSet(new Set(c))}static of(...c){return ModelicoSet.fromArray(c)}static metadata(c){return iterableMetadata(ModelicoSet,c)}static innerTypes(){return emptyObject}static EMPTY(){return EMPTY_SET||ModelicoSet.of()}}ModelicoSet.displayName="ModelicoSet";var ModelicoSet$1=Object.freeze(ModelicoSet);const proxyToSelf=(c,e,h,j,l)=>{return c.includes(l)?(...m)=>{const o=j[l](...m);return proxyFactory(c,e,h,o)}:j[l]},proxyToInner=(c,e,h,j,l,m,o)=>{return h.includes(o)?(...p)=>{const q=m.setIn([],e.apply(c,p));return proxyFactory(h,j,l,q)}:j.includes(o)?(...p)=>{e.apply(c,p);const q=m.setIn([],c);return proxyFactory(h,j,l,q)}:(...p)=>{return e.apply(c,p)}},proxyFactory=(c,e,h,j)=>{return new Proxy(j,{get:(m,o)=>{if(o in m)return proxyToSelf(c,e,h,m,o);const p=h(m.inner()),q=p[o];return"function"==typeof q?proxyToInner(p,q,c,e,h,m,o):q}})},formatError=(c,e,h,j=[])=>["Invalid JSON at \""+j.join(" > ")+"\". According to the schema\n",JSON.stringify(e,null,2)+"\n","the value\n",JSON.stringify(h,null,2)+"\n",c.errors[0].message].join("\n"),formatDefaultValueError=(c,e,h)=>["Invalid default value. According to the schema\n",JSON.stringify(e,null,2)+"\n","the default value\n",JSON.stringify(h,null,2)+"\n",c.errors[0].message].join("\n");var ajvMetadata=(c={validate:T})=>{const e=M.metadata(),h={},{_:j,base:l,asIs:m,any:o,string:p,number:q,boolean:r,date:s,enumMap:t,list:u,map:w,stringMap:y,set:z,maybe:A,withDefault:B}=e,C=(F,G,H=identity)=>(I,J,K)=>{if(""!==I)return J;const L=G===emptyObject||c.validate(G,H(J));if(!L)throw TypeError(formatError(c,G,J,K));return F.reviver("",J,K)},D=(F,G,H)=>(I,J)=>{if(""!==I)return J;const K=C(F,G)(I,J);return C(o(),H,(L)=>L.inner())(I,K)},E=(F,G,H=emptyObject,I=always(emptyObject))=>{const J=G===emptyObject&&H===emptyObject?emptyObject:Object.assign({},G,H),K=C(F,J);return Object.assign({},F,{reviver:K,ownSchema:always(J),schema:()=>Object.assign({},J,I())})};return h.ajv_=(F,G=emptyObject,H)=>{const I=j(F,H);return E(I,emptyObject,G,()=>getSchema$1(I))},h.ajvBase=(F,G=emptyObject)=>{const H=l(F);return E(H,{type:"object"},G,()=>getSchema$1(H))},h.ajvAsIs=(F,G=identity)=>E(m(G),F),h.ajvAny=(F)=>h.ajvAsIs(F),h.ajvNumber=(F,G=emptyObject)=>{const{wrap:H=!1}=G,I=q(G);if(!H)return E(I,{type:"number"},F);const J=Object.assign({type:"number"},F),K=D(I,{anyOf:[{type:"number"},{type:"string",enum:["-0","-Infinity","Infinity","NaN"]}]},J);return Object.assign({},I,{reviver:K,ownSchema:always(J),schema:always(J)})},h.ajvString=(F)=>E(p(),{type:"string"},F),h.ajvBoolean=(F)=>E(r(),{type:"boolean"},F),h.ajvDate=(F)=>E(s(),{type:"string",format:"date-time"},F),h.ajvEnum=(F)=>{const G=j(F);return E(G,{type:"string",enum:Object.keys(G.enumerators)})},h.ajvEnumMap=(F,G,H)=>{const I=Object.keys(G.enumerators),J=`^(${I.join("|")})$`;return E(t(G,H),{type:"object",maxProperties:I.length,additionalProperties:!1,patternProperties:{[J]:{}}},F,()=>({patternProperties:{[J]:getSchema$1(H)}}))},h.ajvList=(F,G)=>E(u(G),{type:"array"},F,()=>({items:getSchema$1(G)})),h.ajvMap=(F,G,H)=>{const I={type:"array",items:{type:"array",minItems:2,maxItems:2}};return E(w(G,H),I,F,()=>({items:Object.assign({items:[getSchema$1(G),getSchema$1(H)]},I.items)}))},h.ajvStringMap=(F,G)=>E(y(G),{type:"object"},F,()=>({additionalProperties:!1,patternProperties:{".*":getSchema$1(G)}})),h.ajvSet=(F,G)=>E(z(G),{type:"array",uniqueItems:!0},F,()=>({items:getSchema$1(G)})),h.ajvMaybe=(F)=>E(A(F),emptyObject,emptyObject,()=>getSchema$1(F)),h.ajvWithDefault=(F,G)=>{const H=getSchema$1(F),I=c.validate(H,G);if(!I)throw TypeError(formatDefaultValueError(c,H,G));return E(B(F,G),emptyObject,emptyObject,always(H))},Object.freeze(Object.assign(h,e))},asIs=(c=identity)=>Object.freeze({type:c,reviver:asIsReviver(c)});const internalNonMutators=["set","setIn"],mapNonMutators=internalNonMutators,mapMutators=["delete","clear"],setNonMutators=internalNonMutators,setMutators=["add","delete","clear"],listNonMutators=internalNonMutators.concat(["concat","slice","filter"]),listMutators=["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],base=(c)=>Object.freeze({type:c,reviver:reviverFactory(c)}),_=(c,e=[])=>c.metadata?c.metadata(...e):base(c),metadata=()=>Object.freeze({_,base,asIs,any:always(asIs(identity)),number:({wrap:c=!1}={})=>c?ModelicoNumber$1.metadata():asIs(Number),string:always(asIs(String)),boolean:always(asIs(Boolean)),date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$1.metadata,map:ModelicoMap$1.metadata,stringMap:StringMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata,withDefault:(c,e)=>{const h=reviverOrAsIs(c)("",e);return Object.freeze(Object.assign({},c,{default:h}))}}),proxyMap=partial(proxyFactory,mapNonMutators,mapMutators,identity),fromJS=(c,e)=>_(c).reviver("",e),genericsFromJS=(c,e,h)=>_(c,e).reviver("",h),ajvFromJS=(c,e,h,j)=>c(e,h).reviver("",j),ajvGenericsFromJS=(c,e,h,j,l)=>c(e,h,j).reviver("",l),createModel=(c,e="ModelicoModel")=>{return class extends Base$1{get[Symbol.toStringTag](){return e}static innerTypes(h,j){return"function"==typeof c?c(h,j):Object.freeze(c)}}};var M={about:Object.freeze({version,author,homepage,license}),Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum,EnumMap:EnumMap$1,List:List$1,Map:ModelicoMap$1,StringMap:StringMap$1,Maybe:Maybe$1,Base:Base$1,Set:ModelicoSet$1,createModel,fields:(c)=>c[fieldsSymbol](),symbols,fromJS,genericsFromJS,fromJSON:(c,e)=>fromJS(c,JSON.parse(e)),genericsFromJSON:(c,e,h)=>genericsFromJS(c,e,JSON.parse(h)),ajvFromJS,ajvGenericsFromJS,ajvFromJSON:(c,e,h,j)=>ajvFromJS(c,e,h,JSON.parse(j)),ajvGenericsFromJSON:(c,e,h,j,l)=>ajvGenericsFromJS(c,e,h,j,JSON.parse(l)),metadata,ajvMetadata,getSchema:getSchema$1,withValidation,proxyMap,proxyEnumMap:proxyMap,proxyStringMap:proxyMap,proxyList:partial(proxyFactory,listNonMutators,listMutators,(c)=>[...c]),proxySet:partial(proxyFactory,setNonMutators,setMutators,identity),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators,identity)};export default M;

