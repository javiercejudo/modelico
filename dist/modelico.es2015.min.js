var version="19.0.2",author="Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)",license="MIT",homepage="https://github.com/javiercejudo/modelico#readme";const typeSymbol=Symbol("type"),fieldsSymbol=Symbol("fields"),get=(c/* : string */)=>(e/* : Object */)=>e[c],pipe2=(c/* : Function */,e/* : Function */)=>(...g/* : Array<mixed> */)=>e(c(...g)),not=(c/* : boolean */)=>/* : boolean */!c,identity=/* :: <T> */(c/* : T */)=>/* : T */c,partial=(c/* : Function */,...e/* : Array<mixed> */)=>c.bind(void 0,...e),asIsReviver=(c/* : Function */)=>(e/* : string */,g/* : mixed */)=>c(g),always=/* :: <T> */(c/* : T */)=>()=>/* : T */c,isNothing=(c/* : mixed */)=>/* : boolean */null==c||Number.isNaN(c),isSomething=pipe2(isNothing,not),defaultTo=(c/* : mixed */)=>(e/* : mixed */)=>isNothing(e)?c:e,objToArr=(c/* : Object */)=>Object.keys(c).map(e=>[e,c[e]]),reviverOrAsIs=pipe2(get("reviver"),defaultTo(asIsReviver(identity))),isPlainObject=(c/* : mixed */)=>/* : boolean */"object"==typeof c&&!!c,emptyObject=Object.freeze({}),haveSameType=(c/* : any */,e/* : any */)=>/* : boolean */null==c||null==e?c===e:c.constructor===e.constructor,haveDifferentTypes=pipe2(haveSameType,not),getInnerTypes=(c/* : number */,e/* : Function */)=>{if(!e.innerTypes)throw Error(`missing static innerTypes for ${e.displayName||e.name}`);return e.innerTypes(c+1,e)},unsupported=(c/* : string */)=>{throw Error(c)},innerTypesCache=new WeakMap,getInnerTypesWithCache=(c,e)=>{return innerTypesCache.has(e)||innerTypesCache.set(e,getInnerTypes(c,e)),innerTypesCache.get(e)},plainObjectReviverFactory=(c,e,g,h)=>Object.keys(h).reduce((j,l)=>{const m=getInnerTypesWithCache(c,e),n=m[l];return j[l]=n?reviverOrAsIs(n)(g,h[l]):h[l],j},{}),reviverFactory=(c,e)=>(g,h)=>{if(""!==g)return h;const j=isPlainObject(h)?plainObjectReviverFactory(c,e,g,h):h;return new e(j)};// @flow
class Base{constructor(c,e=emptyObject,g){if(!isPlainObject(e))throw TypeError(`expected an object with fields for ${c.displayName||c.name} but got ${e}`);Object.freeze(e);const h=getInnerTypes(0,c);g=defaultTo(this)(g),g[typeSymbol]=always(c),g[fieldsSymbol]=always(e),Object.keys(h).forEach(j=>{const l=e[j];let m=M.Maybe.EMPTY;if(isSomething(l))m=l;else if(h[j].type!==M.Maybe)throw TypeError(`no value for key "${j}"`);g[j]=always(m)})}set(c,e){const g=Object.assign({},this[fieldsSymbol](),{[c]:e});return new(this[typeSymbol]())(g)}setPath(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const g=this[c[0]]();return g.setPath?this.set(c[0],g.setPath(c.slice(1),e)):this.set(c[0],e)}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&JSON.stringify(this)===JSON.stringify(c)}toJSON(){return this[fieldsSymbol]()}static factory(...c){return new Base(...c)}}var Base$1=Object.freeze(Base);const reviverFactory$2=c=>(e,g)=>{if(""!==e)return g;const h=null===g?null:c.reviver(e,g);return new Maybe(h)};class Nothing{toJSON(){return null}}class Just{constructor(c){this.get=always(c),Object.freeze(this)}toJSON(){const c=this.get();return c.toJSON?c.toJSON():c}}const nothing=new Nothing;class Maybe extends Base$1{constructor(c,e=!0){super(Maybe);const g=e&&isNothing(c)?nothing:new Just(c);this.inner=always(g),Object.freeze(this)}set(c,e){if(this.isEmpty())return this;const g=this.inner().get();return new Maybe(g.set(c,e))}setPath(c,e){if(0===c.length)return Maybe.of(e);if(this.isEmpty())return this;const g=this.inner().get(),h=g.setPath?g.setPath(c,e):null;return Maybe.of(h)}isEmpty(){return this.inner()===nothing}getOrElse(c){return this.isEmpty()?c:this.inner().get()}map(c){return this.isEmpty()?this:Maybe.ofAny(c(this.inner().get()))}toJSON(){return this.inner().toJSON()}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=this.inner(),g=c.inner();if(this.isEmpty()||c.isEmpty())return e===g;const h=e.get(),j=g.get();return isSomething(h)&&h.equals?h.equals(j):Object.is(h,j)}static of(c){return new Maybe(c)}static ofAny(c){return new Maybe(c,!1)}static metadata(c){return Object.freeze({type:Maybe,reviver:reviverFactory$2(c)})}static innerTypes(){return emptyObject}}Maybe.displayName="Maybe",Maybe.EMPTY=Maybe.of();var Maybe$1=Object.freeze(Maybe);const enumeratorsReducer=(c,e)=>Object.assign(c,{[e]:{code:e}}),reviverFactory$3=c=>(e,g)=>{const h=c[g];if(isNothing(h))throw TypeError(`missing enumerator (${g})`);return h};class Enum extends Base$1{constructor(c){const e=Array.isArray(c)?c.reduce(enumeratorsReducer,{}):c;super(Enum),Object.getOwnPropertyNames(e).forEach(g=>{this[g]=always(e[g]),e[g].toJSON=always(g)}),Object.defineProperty(this,"metadata",{value:always(Object.freeze({type:Enum,reviver:reviverFactory$3(e)})),enumerable:!1}),Object.freeze(this)}static fromObject(c){return new Enum(c)}static fromArray(c){return new Enum(c)}static innerTypes(){return emptyObject}}Enum.displayName="Enum";var Enum$1=Object.freeze(Enum);const set=(c,e,g,h)=>{const j=c.inner();return j.set(g,h),e.fromMap(j)},metadata$1=(c,e)=>{return Object.freeze({type:c,reviver:e})};class AbstractMap extends Base$1{constructor(c,e){if(super(c),isNothing(e))throw TypeError("missing map");const g=new Map(e);this.inner=()=>new Map(g),this[Symbol.iterator]=()=>g[Symbol.iterator]()}setPath(c,e){if(0===c.length)return new(this[typeSymbol]())(e);const g=this.inner().get(c[0]);return g.setPath?this.set(c[0],g.setPath(c.slice(1),e)):this.set(c[0],e)}equals(c){if(this===c)return!0;if(haveDifferentTypes(this,c))return!1;const e=[...this],g=[...c];return!(e.length!==g.length)&&e.every((h,j)=>{const l=g[j];return h.every((m,n)=>{const o=l[n];return isSomething(m)&&m.equals?m.equals(o):Object.is(m,o)})})}}var AbstractMap$1=Object.freeze(AbstractMap);const parseMapper=(c,e)=>g=>{const h=reviverOrAsIs(c),j=h("",g[0]),l=reviverOrAsIs(e),m=l("",g[1]);return[j,m]},reviverFactory$4=(c,e)=>(g,h)=>{if(""!==g)return h;const j=null===h?null:new Map(h.map(parseMapper(c,e)));return ModelicoMap.fromMap(j)};class ModelicoMap extends AbstractMap$1{constructor(c){super(ModelicoMap,c),Object.freeze(this)}set(c,e){return set(this,ModelicoMap,c,e)}toJSON(){return[...this.inner()]}static fromMap(c){return new ModelicoMap(c)}static fromArray(c){return ModelicoMap.fromMap(new Map(c))}static of(...c){const e=c.length;if(1==e%2)throw TypeError("Map.of requires an even number of arguments");const g=[];for(let h=0;h<e;h+=2)g.push([c[h],c[h+1]]);return ModelicoMap.fromArray(g)}static fromObject(c){return ModelicoMap.fromArray(objToArr(c))}static metadata(c,e){return metadata$1(ModelicoMap,reviverFactory$4(c,e))}static innerTypes(){return emptyObject}}ModelicoMap.displayName="ModelicoMap",ModelicoMap.EMPTY=ModelicoMap.of();var ModelicoMap$1=Object.freeze(ModelicoMap);const stringifyReducer=(c,e)=>{return c[e[0].toJSON()]=e[1],c},parseMapper$1=(c,e,g)=>h=>{const j=reviverOrAsIs(c),l=j("",h),m=reviverOrAsIs(e),n=m("",g[h]);return[l,n]},reviverFactory$5=(c,e)=>(g,h)=>{if(""!==g)return h;const j=null===h?null:new Map(Object.keys(h).map(parseMapper$1(c,e,h)));return new EnumMap(j)};class EnumMap extends AbstractMap$1{constructor(c){super(EnumMap,c),Object.freeze(this)}set(c,e){return set(this,EnumMap,c,e)}toJSON(){return[...this.inner()].reduce(stringifyReducer,{})}static fromMap(c){return new EnumMap(c)}static fromArray(c){return EnumMap.fromMap(new Map(c))}static of(...c){const e=c.length;if(1==e%2)throw TypeError("EnumMap.of requires an even number of arguments");const g=[];for(let h=0;h<e;h+=2)g.push([c[h],c[h+1]]);return EnumMap.fromArray(g)}static metadata(c,e){return metadata$1(EnumMap,reviverFactory$5(c,e))}static innerTypes(){return emptyObject}}EnumMap.displayName="EnumMap",EnumMap.EMPTY=EnumMap.of();var EnumMap$1=Object.freeze(EnumMap);const reviver=(c,e)=>{return ModelicoNumber.of(e)};class ModelicoNumber extends Base$1{constructor(c){if(super(ModelicoNumber),!Number.isNaN(c)&&isNothing(c))throw TypeError("missing number");this.inner=always(+c),Object.freeze(this)}set(){unsupported("Number.set is not supported")}setPath(c,e){return 0===c.length?ModelicoNumber.of(e):void unsupported("ModelicoNumber.setPath is not supported for non-empty paths")}toJSON(){const c=this.inner();return Object.is(c,-0)?"-0":Object.is(c,1/0)?"Infinity":Object.is(c,-(1/0))?"-Infinity":Object.is(c,NaN)?"NaN":c}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&Object.is(this.inner(),c.inner())}static of(c){return new ModelicoNumber(c)}static metadata(){return Object.freeze({type:ModelicoNumber,reviver})}static innerTypes(){return emptyObject}}ModelicoNumber.displayName="ModelicoNumber";var ModelicoNumber$1=Object.freeze(ModelicoNumber);const reviver$1=(c,e)=>{const g=null===e?null:new Date(e);return new ModelicoDate(g)};class ModelicoDate extends Base$1{constructor(c){if(super(ModelicoDate),isNothing(c))throw TypeError("missing date");const e=new Date(c.getTime());this.inner=()=>new Date(e.getTime()),Object.freeze(this)}set(){unsupported("Date.set is not supported")}setPath(c,e){return 0===c.length?ModelicoDate.of(e):void unsupported("Date.setPath is not supported for non-empty paths")}toJSON(){return this.inner().toISOString()}equals(c){return!(this!==c)||!haveDifferentTypes(this,c)&&this.toJSON()===c.toJSON()}static of(c){return new ModelicoDate(c)}static metadata(){return Object.freeze({type:ModelicoDate,reviver:reviver$1})}static innerTypes(){return emptyObject}}ModelicoDate.displayName="ModelicoDate";var ModelicoDate$1=Object.freeze(ModelicoDate);const iterableReviverFactory=(c,e)=>(g,h)=>{if(""!==g)return h;const j=partial(reviverOrAsIs(e),g),l=null===h?null:h.map(j);return new c(l)},iterableMetadata=(c,e)=>{return Object.freeze({type:c,reviver:iterableReviverFactory(c,e)})},iterableEquals=(c,e)=>{if(c===e)return!0;if(haveDifferentTypes(c,e))return!1;const g=[...c],h=[...e];return!(g.length!==h.length)&&g.every((j,l)=>{const m=h[l];return isSomething(j)&&j.equals?j.equals(m):Object.is(j,m)})};class List extends Base$1{constructor(c){if(super(List),isNothing(c))throw TypeError("missing list");const e=[...c];this.inner=()=>[...e],this[Symbol.iterator]=()=>e[Symbol.iterator](),Object.freeze(this)}set(c,e){const g=this.inner();return g[c]=e,List.fromArray(g)}setPath(c,e){if(0===c.length)return List.fromArray(e);const g=this.inner()[c[0]];return g.setPath?this.set(c[0],g.setPath(c.slice(1),e)):this.set(c[0],e)}toJSON(){return this.inner()}equals(c){return iterableEquals(this,c)}static fromArray(c){return new List(c)}static of(...c){return List.fromArray(c)}static metadata(c){return iterableMetadata(List,c)}static innerTypes(){return emptyObject}}List.displayName="List",List.EMPTY=List.of();var List$1=Object.freeze(List);class ModelicoSet extends Base$1{constructor(c){if(super(ModelicoSet),isNothing(c))throw TypeError("missing set");const e=new Set(c);this.inner=()=>new Set(e),this[Symbol.iterator]=()=>e[Symbol.iterator](),Object.freeze(this)}set(){unsupported("Set.set is not supported")}setPath(c,e){return 0===c.length?new ModelicoSet(e):void unsupported("Set.setPath is not supported for non-empty paths")}toJSON(){return[...this.inner()]}equals(c){return iterableEquals(this,c)}static fromSet(c){return new ModelicoSet(c)}static fromArray(c){return ModelicoSet.fromSet(new Set(c))}static of(...c){return ModelicoSet.fromArray(c)}static metadata(c){return iterableMetadata(ModelicoSet,c)}static innerTypes(){return emptyObject}}ModelicoSet.displayName="ModelicoSet",ModelicoSet.EMPTY=ModelicoSet.of();var ModelicoSet$1=Object.freeze(ModelicoSet);const Any=c=>identity(c);var Any$1=Object.freeze(Any);const proxyToSelf=(c,e,g,h)=>{return c.includes(h)?(...j)=>{const l=g[h](...j);return proxyFactory(c,e,l)}:g[h]},proxyToInner=(c,e,g,h,j,l)=>{return g.includes(l)?(...m)=>{const n=j.setPath([],e.apply(c,m));return proxyFactory(g,h,n)}:h.includes(l)?(...m)=>{e.apply(c,m);const n=j.setPath([],c);return proxyFactory(g,h,n)}:(...m)=>{return e.apply(c,m)}},proxyFactory=(c,e,g)=>{return new Proxy(g,{get:(h,j)=>{if(j in h)return proxyToSelf(c,e,h,j);const l=h.inner(),m=l[j];return"function"==typeof m?proxyToInner(l,m,c,e,h,j):m}})};var asIs=(c=Any$1)=>Object.freeze({type:c,reviver:asIsReviver(c)});const internalNonMutators=["set","setPath"],mapNonMutators=internalNonMutators,mapMutators=["set","delete","clear"],setNonMutators=internalNonMutators,setMutators=["add","delete","clear"],listNonMutators=internalNonMutators.concat(["concat","slice","filter"]),listMutators=["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"],dateNonMutators=internalNonMutators,dateMutators=["setDate","setFullYear","setHours","setMinutes","setMilliseconds","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"],_=function(c,e=0,g=[]){return c.metadata?c.metadata(...g):Object.freeze({type:c,reviver:reviverFactory(e,c)})},metadata=Object.freeze({_,asIs,any:always(asIs(Any$1)),number:({wrap:c=!1}={})=>c?ModelicoNumber$1.metadata():asIs(Number),string:always(asIs(String)),boolean:always(asIs(Boolean)),regExp:always(asIs(RegExp)),fn:always(asIs(Function)),date:ModelicoDate$1.metadata,enumMap:EnumMap$1.metadata,list:List$1.metadata,map:ModelicoMap$1.metadata,maybe:Maybe$1.metadata,set:ModelicoSet$1.metadata});var M={about:Object.freeze({version,author,homepage,license}),Any:Any$1,Number:ModelicoNumber$1,Date:ModelicoDate$1,Enum:Enum$1,EnumMap:EnumMap$1,List:List$1,Map:ModelicoMap$1,Maybe:Maybe$1,Base:Base$1,Set:ModelicoSet$1,fields:c=>c[fieldsSymbol](),fromJSON:(c,e)=>JSON.parse(e,_(c).reviver),genericsFromJSON:(c,e,g)=>JSON.parse(g,_(c,0,e).reviver),metadata,proxyMap:partial(proxyFactory,mapNonMutators,mapMutators),proxyEnumMap:partial(proxyFactory,mapNonMutators,mapMutators),proxyList:partial(proxyFactory,listNonMutators,listMutators),proxySet:partial(proxyFactory,setNonMutators,setMutators),proxyDate:partial(proxyFactory,dateNonMutators,dateMutators)};export default M;

